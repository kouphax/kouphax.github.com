<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:architecture</id><updated>Wed Jun 21 00:00:00 UTC 2017</updated><title type="text">Yo! Briefcase: architecture</title><link rel="self" href="https://yobriefca.se/feed/architecture.xml"></link><entry><title>How to do unnecessary things in long winded ways...</title><updated>Wed Jun 21 00:00:00 UTC 2017</updated><author><name>James Hughes</name></author><link href="/presentations/clojurescraping.pdf"></link><id>urn:yobriefca-se:feed:post:How to do unnecessary things in long winded ways...</id><content type="html"></content></entry><entry><title>The Twelve Factor App (Redux)</title><updated>Sun Sep 20 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="/presentations/twelve-factor-app-redux.pdf"></link><id>urn:yobriefca-se:feed:post:The Twelve Factor App (Redux)</id><content type="html"></content></entry><entry><title>The Builder Pattern</title><updated>Fri May 15 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="/presentations/thebuilderpattern.pdf"></link><id>urn:yobriefca-se:feed:post:The Builder Pattern</id><content type="html"></content></entry><entry><title>The Twelve Factor App</title><updated>Tue Jan 20 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="/presentations/twelve-factor-app.pdf"></link><id>urn:yobriefca-se:feed:post:The Twelve Factor App</id><content type="html"></content></entry><entry><title>Continuous Delivery &amp; Boy Scouting Your Deployment Pipeline</title><updated>Sun Jan 05 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/01/05/continuous-delivery-and-boy-scouting-your-deployment-pipeline/"></link><id>urn:yobriefca-se:feed:post:Continuous Delivery &amp; Boy Scouting Your Deployment Pipeline</id><content type="html">&lt;p&gt;Talking to teams and stakeholders within organisations over the last few years I've seen very strong concerns that &lt;a href="http://en.wikipedia.org/wiki/Continuous_delivery"&gt;continuous delivery&lt;/a&gt; was not for them. Usually it was because there was already a process in place - a process that involved lead times in the weeks or months, a lot of repeated manual work and many phases of QA prior to any release being deployed by some third party vendor. They worry, especially, that they would have very little chance of automating everything in the process.&lt;/p&gt;&lt;h2&gt;Throwing the baby out with the bath water&lt;/h2&gt;&lt;p&gt;The goal of continuous delivery isn't actually about automating everything (it just so happens that in many cases automation has significant benefits). Continuous delivery is about reducing the time to deliver a single change to production so to establish a tighter feedback loop between your company or product and your users. &lt;/p&gt;&lt;p&gt;However a lot of the time taken to deploy a release may well be out of your control, usually for the reasons quoted above. The thing is though, things change. It takes time but things always change. To quote Dr. Ian Malcolm - "&lt;a href="http://www.youtube.com/watch?v=SkWeMvrNiOM"&gt;Life finds a way&lt;/a&gt;". For example - your QA department might well suddenly discover the joys of automating a lot of their manual regression tests, your service management contract may expire and some new executive might suggest you try this new fangled "agile cloud as a service stuff" on the back of promises like 10x productivity&lt;a name="_1"&gt;&lt;/a&gt;&lt;a href="#1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. There are lots of reasons, and most of them a blessing in disguise even if they are a bit ill-informed. &lt;strong&gt;Being ready allows you to capitalise on this organistational change&lt;/strong&gt; and make it last.&lt;/p&gt;&lt;h2&gt;Visualise your Pipeline&lt;/h2&gt;&lt;p&gt;Draw a diagram or outline the steps that a change or single commit goes through to get onto a production box. This isn't done enough in projects, there are fragments of it in peoples heads and there are foggy areas of uncertainty. Drawing a pipeline, one that covers multiple deparments is actually quite an eye opener. &lt;/p&gt;&lt;p&gt;Another thing that this task does is help you realise that deployment isn't a single big black box that is always as slow as the slowest step. Its a series of steps and by visualising it you can simulate changes to it. That 1/2 day it takes to deploy to a preview environment for developer sanity checking may pale in comparison to the 4 week period that you wait to see if the production deployment was successful but bringing that 1/2 day down to 10 minutes for a team of, say, 6 developers has a more long term benefit. Even more, if you get to extend the process for deploying to preview into the QA environments at a later date - the work is mostly already done&lt;a name="_2"&gt;&lt;/a&gt;&lt;a href="#2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;So you may not have hugely reduced the time to a &lt;strong&gt;production&lt;/strong&gt; release but you've helped tighten up the development feedback and prepared yourself for a future where these changes can be reused further down the pipeline.&lt;/p&gt;&lt;h2&gt;Boy Scouting&lt;/h2&gt;&lt;p&gt;But a lot of this work is far from trivial and right now it might be hard to sell it to the people holding the purse strings and Gantt charts so what can you do? Well, a few years ago Robert C. Martin (Uncle Bob) suggested that you can &lt;a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule"&gt;apply the Boy Scout rule to code bases&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The Boy Scouts have a rule: "Always leave the campground cleaner than you found it." If you find a mess on the ground, you clean it up regardless of who might have made the mess. You intentionally improve the environment for the next group of campers.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Applying this rule to a code base means that every check in you should, &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;tidy up a little bit of extra code,&lt;/li&gt;
  &lt;li&gt;add another useful unit test,&lt;/li&gt;
  &lt;li&gt;refactor a tiny bit of code, or,&lt;/li&gt;
  &lt;li&gt;tidy up a bit of formatting&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Anything to have a positive impact on the quality of code in the project. &lt;/p&gt;&lt;p&gt;I proffer that &lt;strong&gt;the same rule can be applied to your deployment pipeline&lt;/strong&gt;. Things like - introduce a script that starts up a simple vagrant environment, add a little bit of Puppet/Chef/Salt to create a production-like environment on developers machines, automate that file copy/paste process that Steve in Team B does during every release with a script, document the deployment process, publish the deployment pipeline, add a bit more validation to your CI server. Anything that makes the pipeline that tiny bit less painful to flow through.&lt;/p&gt;&lt;p&gt;In time these small incremental changes have a compound positive effect that results in fewer issues with deployment (and on-boarding) and acts as an example to people involved downstream in the deployment pipeline. &lt;/p&gt;&lt;p&gt;Ultimately the technical change required to move towards continuous delivery takes time and effort but it is nothing compared to the cultural and organisational changes. Proactively addressing the technical changes that can be made now can benefit your current process and also prepare you for a more effective delivery model in the future.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="1"&gt;&lt;/a&gt;&lt;a href="#_1"&gt;1&lt;/a&gt;: Both of these things have happened in recent years to projects I've been involved in.&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="2"&gt;&lt;/a&gt;&lt;a href="#_2"&gt;2&lt;/a&gt;: We haven't even pointed out that this developer deployment is going to be of immediate benefit for on-boarding new team members as well.&lt;/sup&gt;&lt;/p&gt;</content></entry><entry><title>Building Systems: Libraries and Frameworks</title><updated>Sat Jan 04 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/01/04/building-systems-libraries-and-frameworks/"></link><id>urn:yobriefca-se:feed:post:Building Systems: Libraries and Frameworks</id><content type="html">&lt;p&gt;My &lt;a href="http://yobriefca.se/blog/2013/04/29/micro-service-architecture/"&gt;Micro Service Architecture post&lt;/a&gt; has been by far my most popular post and has generated a lot of discussion. A recurring theme across these discussions is that of using small "fit for purpose" libraries or micro frameworks over larger frameworks. So I wanted to capture some of my thoughts on this.&lt;/p&gt;&lt;h2&gt;What is Small/Large?&lt;/h2&gt;&lt;p&gt;My view, as already expressed in the original post, is that smaller frameworks and libraries should be favoured over larger frameworks when building micro services. In fact thats my general rule of thumb when building systems of any scale. But of course this is entirely subjective - what I define as small is probably considerably large in some other peoples views (especially as we are being completely language and platform agnostic here). But there are a few things I consider when deciding if a library/framework is small or large,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The goal of the library/framework&lt;/strong&gt;. Small things set out to fix a single problem, big things aim to be a panacea. &lt;a href="http://www.mindrot.org/projects/jBCrypt/"&gt;jBcrypt&lt;/a&gt; does strong password hashing, &lt;a href="http://commons.apache.org/"&gt;Apache Commons&lt;/a&gt; does everything. &lt;a href="http://www.playframework.com/documentation/2.0/ScalaAnorm"&gt;ANORM&lt;/a&gt; gives you some simple sugar over JDBC, &lt;a href="http://hibernate.org/"&gt;Hibernate&lt;/a&gt; has its own flipping query language for crying out loud.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Prefer libraries over frameworks&lt;/strong&gt;. The difference being you call libraries whereas frameworks call you - frameworks are Soviet Russia. This definition makes libraries inherently more composable than frameworks. Libraries are often less prone to abstraction distraction (or at the very least their abstractions are rather specific to their goal). &lt;strong&gt;Proper&lt;/strong&gt; usage of libraries allows you to roll your own framework and conventions rather than workaround generic conventions baked into frameworks.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Feature count&lt;/strong&gt;. Kitchen-sink libraries or frameworks are often just full of features you don't need. "Well don't use them then" - ah if it were that simple. The unix philosophy should apply to services and libraries (do one thing and do it well). I mean, Apache Commons? C'mon Really? Why not just use a language with a decent core library instead?&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Useful/Redundant Feature Ratio&lt;/strong&gt;. If your framework/library has more features I don't need than ones I do, or if I need to use a feature I don't need or want just to use the other features - thats big. This is one reason why I consider Spring to be "big". It's entire premise is built around a big IoC container. The way I build systems I simply don't need an IoC container&lt;a name="_1"&gt;&lt;/a&gt;&lt;a href="#1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. So being forced to use something I don't need to gain other features I can get elsewhere without the overhead - well thats big&lt;a name="_2"&gt;&lt;/a&gt;&lt;a href="#2"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Tooling support&lt;/strong&gt;. If your library or framework needs a special IDE or admin application or other 3rd party installs - its big. Not necessarily "bad" but "big".&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Why Small?&lt;/h2&gt;&lt;p&gt;There are a million analogies you can use here, like "I don't buy a taco kit just to get taco shells" but lets try and stick to the reality here. I'm also going to avoid the obvious stuff like "frameworks lead to leaky abstractions", "frameworks lead to compromise or extra work" - there are plenty of articles about that stuff and YMMV anyway.&lt;/p&gt;&lt;p&gt;Firstly there is the obvious point that if you running a large number of micro services on a small number of machines then footprint matters, extra stuff loaded into a services memory allocation that aren't used creates a lot of waste but this doesn't really apply to most small/medium sized systems in reality.&lt;/p&gt;&lt;p&gt;Secondly design. Large frameworks are designed with rather monolithic architectures in mind. Modular service based systems have significantly different design needs that are orthogonal to the feature sets of large frameworks. This leads to questions like "Why not just use Spring for this instead of Dropwizard, I know Spring and you can do the same thing with them?". Ultimately it leads to design decisions that are more suited to monolithic architectures resulting a sort of schizophrenic architecture that becomes difficult to reason about. You'll have to actively work against other peoples design decisions instead of establishing your own.&lt;/p&gt;&lt;p&gt;Finally there is an argument that frameworks reduce the LOC metric which I think is &lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;a terrible metric in the first place, and,&lt;/li&gt;
  &lt;li&gt;just plain wrong.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Just because you're taking other peoples work, neatly tucked away in a jar or package, and writing some of your own code around it doesn't mean you've reduced the LOC metric in any meaningful way. Yeah you've written less but if thats all you care about... mon dieu! &lt;/p&gt;&lt;p&gt;In fact the minute you take on other peoples code you've become responsible for it, you need to have some understanding about it, you need to maintain it (security holes etc.) and one day you'll stepping through that code to understand why things behave the way they do. Working with libraries in this context is actually a lot easier than frameworks, they typically have a much smaller surface area. When it comes to upgrades as well libraries can be significantly easier to manage without affecting other aspects of the system. The quick win you get with frameworks when you start a project will need to be repaid and you better be capable to explaining how your system works - the customers don't care that its a known bug in Rails - it's a bug in the system you delivered to them, you need to fix it. Starting with nothing and knowingly justifying every library inclusion you make will make the process of delivering and maintaining systems much more fluid instead of the promise a huge productivity spike at the start&lt;a name="_3"&gt;&lt;/a&gt;&lt;a href="#3"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Oh, and don't get me started on the fact that many developers see unused features as a challenge.&lt;/p&gt;&lt;p&gt;I've had much better &lt;strong&gt;long term&lt;/strong&gt; success and predictability by avoiding large frameworks and instead composing solutions using only what we needed even if it requires a bit of extra work up front or convincing. Admittedly a frameworks promise of productivity is a difficult thing to move people away from, especially if they married to the framework or don't really think beyond their own role. &lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="1"&gt;&lt;/a&gt;&lt;a href="#_1"&gt;1&lt;/a&gt;: IoC containers are suited to special types of systems - ones that have very large, deep or complex dependency graphs. In other words poorly designed systems.&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="2"&gt;&lt;/a&gt;&lt;a href="#_2"&gt;2&lt;/a&gt;: I know of a project that uses Spring inside their Dropwizard services. It's like people don't realise that you can actually call constructors using &lt;code&gt;new&lt;/code&gt;. Not to mention the fact the &lt;code&gt;initialize()&lt;/code&gt; method in a Dropwizard service is essentially an IoC container. If you're putting a container inside a container you probably need help.&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="3"&gt;&lt;/a&gt;&lt;a href="#_3"&gt;3&lt;/a&gt;: This sort of thinking is articulated really well by &lt;a href="http://dan.bodar.com/2012/02/28/crazy-fast-build-times-or-when-10-seconds-starts-to-make-you-nervous/"&gt;Dan Bodart&lt;/a&gt; in his &lt;a href="http://www.infoq.com/presentations/Crazy-Fast-Build-Times-or-When-10-Seconds-Starts-to-Make-You-Nervous"&gt;Crazy Fast Build Times talk&lt;/a&gt;. His main argument is the tightening up of feedback loops but there are plenty of points that apply here too.&lt;/sup&gt;&lt;/p&gt;</content></entry><entry><title>Micro Service Architecture</title><updated>Mon Apr 29 00:00:00 UTC 2013</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2013/04/29/micro-service-architecture/"></link><id>urn:yobriefca-se:feed:post:Micro Service Architecture</id><content type="html">&lt;p&gt;Micro Service Architecture is an architectural concept that aims to decouple a solution by decomposing functionality into discrete services. Think of it as applying many of the principles of &lt;a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)"&gt;SOLID&lt;/a&gt; at an architectural level, instead of classes you've got services.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/micro-service-architecture.png" alt="Micro Service Architecture" _="_" /&gt;&lt;/p&gt;&lt;p&gt;Conceptually speaking MSA is not particularly difficult to grasp but in practice it does raise many questions. How do these services communicate? What about latency between services? How do you test the services? How do you detect and respond to failure? How do you manage deployments when you have a bunch of interdependencies? So lets expand on some of these throughout this post and see if MSA really is worth the effort.&lt;/p&gt;&lt;h2&gt;Anatomy of a Micro Service&lt;/h2&gt;&lt;p&gt;First things first what actually &lt;strong&gt;is&lt;/strong&gt; a micro service? Well there really isn't a hard and fast definition but from conversations with various people there seems to be a consensus that a micro service is a simple application that sits around the 10-100 LOC mark. Now I realise that line count is an atrocious way to compare implementations so take what you will from that. But they are small, micro even. This means you're not going to find hundreds of tiny services built on top of large frameworks, it's simply not practical. No, simplicity and lightweightyness &lt;sup&gt;(not a real word)&lt;/sup&gt; is the order of the day here. Small frameworks like &lt;a href="http://www.sinatrarb.com/"&gt;Sinatra&lt;/a&gt;, &lt;a href="https://github.com/webbit/webbit"&gt;Webbit&lt;/a&gt;, &lt;a href="http://twitter.github.io/finagle/"&gt;Finagle&lt;/a&gt; &amp;amp; &lt;a href="http://www.senchalabs.org/connect/"&gt;Connect&lt;/a&gt; do just enough to allow you to wrap your actual code in a thin communication layer.&lt;/p&gt;&lt;p&gt;In terms of a footprint these services will be small, you're potentially going to run a lot of them on the same machine so you don't want to be holding on to memory or resources that you aren't intending to use. Once again simple libraries over large frameworks will win out, you'll also find less of a reliance on 3rd party dependencies.&lt;/p&gt;&lt;p&gt;This decoupling at a service level also offers another interesting option. We've pushed a lot of the old application complexity down to infrastructure level. We are no longer bound to a single stack or language. We can play to the strengths of any stack or language now. It's entirely possible to have a system built out with a myriad of languages and libraries, though as we will touch on later this is a double edged sword.&lt;/p&gt;&lt;p&gt;You're also not going to find any true micro service based architectures that are hosted in an application server, that kinds of defeats the point. To this end micro services self host, they grab a port and listen. This means you'll lose any benefits your typical enterprise application server may bring and your service will need to provide some of the more essential ones (instrumentation, monitoring etc.).&lt;/p&gt;&lt;h2&gt;Communication&lt;/h2&gt;&lt;p&gt;This is an interesting one. How do your services communicate? There really isn't a single answer for this, even in a single solution. The most basic approach across the board would be to expose all services over HTTP and pass JSON back and forth. Service discovery (how one service knows where to find another) can be as simple as putting the endpoint details into a configuration file (or simply hardcoded).&lt;/p&gt;&lt;p&gt;You may discover, in certain circumstances, the cost of serialising and deserialising JSON payloads through an entire &lt;em&gt;transaction&lt;/em&gt; is causing bottlenecks. Perhaps JSON isn't suitable at all (binary formats) and so you'll want to look at different protocols, like &lt;a href="https://code.google.com/p/protobuf/"&gt;Protobuf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;But hardcoded urls kind of imply a certain strict coupling and A-B-C workflow. In a layered application this makes sense but moving into a service based architecture means you're not bound by this (potential) constraint. Some communications between services can be completely decoupled, in fact some services could publish events or data blindly. They can just throw it into the ether (or at least a message bus) and maybe one day some service can come along and start listening. Alternatively maybe parts of your system could operate in a batch/offline process, feeding off a queue and flipping bits many hours later.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/micro-service-architecture-comms.png" alt="Micro Service Architecture Comms" _="_" /&gt;&lt;/p&gt;&lt;p&gt;A micro service approach gives you this kind of flexibility without major architectural rework.&lt;/p&gt;&lt;h2&gt;Monitoring &amp;amp; Metrics&lt;/h2&gt;&lt;p&gt;Components of a monolithic, layered solution don't typically fail silently - it either fails to compile or throws exceptions when something is wrong (unless you go out of your way and silently swallow exceptions like some insane person). In a service based approach a service might drop off the face of the earth and it's very easy for no other service to notice (especially in a pub/sub model). This means it's imperative that services are properly monitored and orchestrated. In fact just knowing a service is alive is seldom good enough. Is it providing enough business benefit? Is it even being used anymore? Is it acting as a bottleneck for reliant transactions?&lt;/p&gt;&lt;p&gt;Monitoring is always important but more so in a service based architecture where failure is often less obvious. Good examples of this from the JVM world are &lt;a href="http://metrics.codahale.com/"&gt;Metrics&lt;/a&gt; and &lt;a href="https://github.com/twitter/ostrich"&gt;Ostrich&lt;/a&gt; these libraries not only allow for collection of metrics but provide a means of integrating and reporting that data into other services like &lt;a href="http://www.nagios.org/"&gt;Nagios&lt;/a&gt; or &lt;a href="http://ganglia.sourceforge.net/"&gt;Ganglia&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;Testing&lt;/h2&gt;&lt;p&gt;There is nothing particularly special about testing services in a micro service based system but the point I want to raise here is that you've reduced the need to have a full suite of tests for every service. Because a service does one thing, and should do it well the risk of introducing a system breaking bug is significantly reduced thanks to the natural behavior of a service based system. Now writing tests for the sake of it, or just in case, holds little to no value but still require the same amount of care or attention during refactoring.&lt;/p&gt;&lt;p&gt;I'm not saying &lt;em&gt;don't&lt;/em&gt; test but I am recommending you think before you use the old "No. of Tests" as a value of code quality.&lt;/p&gt;&lt;p&gt;In fact lets go one step further and change the way we test entirely. You've got monitoring in place, at any given time you can know what services are broken and recover. But also why not monitor key business metrics on each service and use them as indicators to know if we've broken something. This is commonly known as a production immune system. If conversions are dropping, or sales have halted then you can make it so your system rolls back to a known stable state and gives you nasty looks until you fix the problem. The same approach can be used for A/B testing and Dark Launching new features and services.&lt;/p&gt;&lt;p&gt;Micro Service Architecture actually makes a whole lot of sense when it comes to ensuring you have a stable system at any scale.&lt;/p&gt;&lt;h2&gt;Applications of Micro Service Architecture&lt;/h2&gt;&lt;p&gt;MSA has a number of interesting applications. Obviously green field solutions of a given size is an obvious use of this approach. Though I say "given size" because the cost incurred at an infrastructure level required to support micro services could outweigh the benefits and, for small systems, a simple web app would be totally acceptable.&lt;/p&gt;&lt;p&gt;Micro Services also have an interesting application in large legacy systems. Working with legacy code is risky at best. For systems that have been running for decades there is a chance there is limited knowledge in how the systems actually works internally. Working with this code can be like working with a house of cards and a simple mistake in one place can have adverse affects elsewhere. These systems are typically mission critical so mistakes can be costly. So just don't touch it. The micro service approach lets you do this. Rather than diving into the legacy code base, write a small service that does what you need (yes you may be duplicating legacy code) and proxy service calls through it (e.g. via nginx/apache etc or purely within code).&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/micro-service-architecture-proxy.png" alt="Micro Service Architecture Proxy" _="_" /&gt;&lt;/p&gt;&lt;p&gt;Now imagine doing this regularly as part of your maintenance and support program. You'll be turning off the old system bit by bit and perhaps eventually be able to turn it off completely.&lt;/p&gt;&lt;h2&gt;Issues&lt;/h2&gt;&lt;p&gt;Micro Service based systems aren't without their problems of course. For one there is a greater need to better understand non-development areas. In days of old before DevOps was a broadly misunderstood marketing term developers would deliver working systems over the wall to operations who would deploy it to production and everything would fail. Of course this was the ops team fault, don't they know anything? Jeez. It was entirely possible for a developer to know only code, running the entire application from their IDE without thinking about how this would work in real life. MSA forces the developers hand to actually be more responsible and actually get involved in scripting of deployments and understanding integration requirements etc.&lt;/p&gt;&lt;p&gt;Another issue that I touched on earlier is the fact, left unchecked you could have hundreds of small services written in hundreds of languages. Simply managing that sort of estate of languages and platforms with their different installations, package managers and requirements can stop a project dead in its tracks.&lt;/p&gt;&lt;p&gt;An anti-pattern has emerged from the MSA approach - often called the Nano-Service architecture. These are systems built on services that are so small that duplication of effort is prevalent and it becomes almost impossible to reason about any particular area of a system easily.&lt;/p&gt;&lt;h2&gt;Macro Post for Micro Services&lt;/h2&gt;&lt;p&gt;The irony of a large wall of text to introduce the concept of micro services is not lost on me but there is lots to consider. Micro Service based systems can produce scalable, fault tolerant systems on fairly low cost hardware. MSA promotes good practices of keeping things lightweight, emerging systems and business monitoring but as with everything should be approached with a rational mindset and solid understanding of what you &lt;strong&gt;need&lt;/strong&gt; to achieve.&lt;/p&gt;</content></entry><entry><title>Technology Techsmology</title><updated>Mon Nov 05 00:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/11/05/technology-techsmology/"></link><id>urn:yobriefca-se:feed:post:Technology Techsmology</id><content type="html">&lt;p&gt;There is an old adage, &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Projects don't fail because of technology decisions&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;The younger me would have got all uppity and defensive when he heard this statement. As a developer/architect type whose main goal is to make key technology decisions on a project (not to mention as a person who likes to grandiously consider themselves a craftsman) this does seem rather belittling. Are you telling me all my decisions are fairly irrelevant? I'll just stay in bed then shall I? &lt;/p&gt;&lt;p&gt;But you know what? The statement is also completely true. &lt;/p&gt;&lt;p&gt;But hey, wait - do you want to know something else? Yes? Good. &lt;/p&gt;&lt;p&gt;The world of technology is not black and white, projects aren't either a success or a failure, it's simply not a binary system. Projects may not fail, but they could be late. They could be well over budget. They could have code bases so toxic that you need to hire contractors to do the work because no one wants to touch it. They could be so overly laden in patterns and complex architecture that even small changes take weeks or months to implement (and who foots the bill for that?). &lt;/p&gt;&lt;p&gt;Technology decisions can indirectly ruin the morale of your staff, muddy the relationship with your customers and generate really high turnover of staff in your company (which may be a good fit for some companies but you can never foster excellence if you don't nurture talent). &lt;/p&gt;&lt;p&gt;This statement can also be used as a weapon - a weapon to excuse bad decisions and hold back change (both good and bad, in short it stiffles learning). People cling to technologies that they used in the past, for fear of more pain with other technologies. They shoehorn their existing skillset into problem domains that aren't a good fit. When this happens, at the extreme you end up with specialists that simply can't adapt to shifts in technology fast enough.&lt;/p&gt;&lt;p&gt;So yeah, projects don't fail because of technology decisions. But you know what - if your dentist turned round to you with an evil grin and a rusty chisel and &lt;a href="http://en.wikipedia.org/wiki/Law_of_the_instrument"&gt;Maslow's Hammer&lt;/a&gt; citing - "No surgery ever went wrong because of a lack of anesthetic" - you're not likely to get in to that chair and open wide. And even if you did (maybe, you're drunk, maybe people keep telling you this dentist is the best, whatever) the experience would be painful, recovery time would be longer and subsequent treatments would probably be more painful. A rather shambling metaphor I admit but I write what my brain dictates - I have not choice in the matter.&lt;/p&gt;&lt;p&gt;Finally, I fully accept that many of these decisions are out of our control. Customers, especially big ones, generally have the final say, they've potentially invested a lot of time on a certain stack and have a lot of legacy (read: code that still works) solutions in play. True, but one of our goals is to at least inform these people of the alternatives and let them make an informed decision - maybe not today but soon enough the cost of developing and maintaining new systems built on out-of-support JDKs will come under scrutiny and they'll need to consider alternatives, alternatives that you've already enlightened them about.&lt;/p&gt;</content></entry></feed>