<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:clojure</id><updated>Tue Aug 04 00:00:00 UTC 2015</updated><title type="text">Yo! Briefcase: clojure</title><link rel="self" href="https://yobriefca.se/feed/clojure.xml"></link><entry><title>Refactoring Towards Transducers</title><updated>Tue Aug 04 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/08/04/refactoring-towards-transducers/"></link><id>urn:yobriefca-se:feed:post:Refactoring Towards Transducers</id><content type="html">&lt;blockquote&gt;&lt;p&gt;This is a quick post but hey at least I'm not &lt;a href="https://yobriefca.se/blog/2015/07/28/window-dot-prompt-in-elm/"&gt;talking&lt;/a&gt; &lt;a href="https://yobriefca.se/blog/2015/07/29/zombie-dice-score-card-in-elm/"&gt;about&lt;/a&gt; &lt;a href="https://yobriefca.se/blog/2015/08/02/deconstructing-your-first-elm-app/"&gt;Elm&lt;/a&gt;. COMBOBREAKER!&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Clojure 1.7 introduced a new, fairly large concept - &lt;a href="http://clojure.org/transducers"&gt;transducers&lt;/a&gt;. Transducers are "composable algorithmic transformations" which means they are little isolated transformer functions. They aren't bound to any particular input or output and as such can be stacked or composed ad-hoc to make neat little pipelines for data processing. &lt;/p&gt;&lt;p&gt;This required a fairly large internal change in the way many collection functions in Clojure behaved. Now most of these functions now accept an arity of one less than they normally do. For example,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;incrementalizer&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case &lt;code&gt;incrementalizer&lt;/code&gt; is defined as a &lt;code&gt;map&lt;/code&gt; function that will perform &lt;code&gt;inc&lt;/code&gt; over whatever it gets passed. We didn't pass &lt;code&gt;map&lt;/code&gt; a data structure to map over and so it returns a transducer. We can use &lt;code&gt;comp&lt;/code&gt; to compose a bunch of these transducers together and run them across a collection using forms such as &lt;code&gt;into&lt;/code&gt;, &lt;code&gt;transduce&lt;/code&gt;, &lt;code&gt;eduction&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;As I was working on a new project recently I had just moved to Clojure 1.7 and so decided to take a stab at refactoring a few utility functions I had into a series of transducers. This post covers how I approached this refactor. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;It's worth noting that this is purely an exercise in refactoring towards transducers. I am not suggesting that this increases performance, is easier to maintain or makes code any more readable. I'm not even suggesting this &lt;strong&gt;should&lt;/strong&gt; be done at all as that depends on the context of your work.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;The original approach looked like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;user&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.java.io&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;io&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.string&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;str&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
            
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-files&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file-seq &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;io/file&lt;/span&gt; &lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;is-xml?&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;str/split&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="s"&gt;"\."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="s"&gt;"xml"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                         
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-xml-files&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;files&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.isFile&lt;/span&gt; &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is-xml?&lt;/span&gt; &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
          &lt;span class="nv"&gt;files&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-xml-paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getAbsolutePath&lt;/span&gt; &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-xml-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-files&lt;/span&gt; &lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
       
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xml-paths&lt;/span&gt; 
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-xml-paths&lt;/span&gt; &lt;span class="s"&gt;"./workspace/xml"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A bit of scrappy code that I wrote interactively while doing some ad-hoc file processing. What we end up with is a list of absolute file paths to some XML files contained within a specified folder. In order to transform a folder path to a list of XML files it does a few things,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;List the contents of the folder using the built-in &lt;code&gt;file-seq&lt;/code&gt; function in Clojure&lt;/li&gt;
  &lt;li&gt;Remove everything in the list that isn't a file (such as pipes and directories)&lt;/li&gt;
  &lt;li&gt;Remove everything in the list without the &lt;code&gt;.xml&lt;/code&gt; extension&lt;/li&gt;
  &lt;li&gt;Call &lt;code&gt;.getAbsolutePath&lt;/code&gt; on the remainder of the list to get the full path as a string&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;Towards Transducers&lt;/h2&gt;&lt;p&gt;Any place that we apply some sort of filtering, mapping, reduction, take etc. over a collection is a candidate for being converted to a transducer. In the previous examples we can identify a few points that can be rewritten as transducers,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code&gt;filter&lt;/code&gt; which actually has 2 checks
  &lt;ul&gt;
    &lt;li&gt;is it a file?&lt;/li&gt;
    &lt;li&gt;is it an xml file?&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;map&lt;/code&gt; that converts a list of XML files into their absolute paths&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If we rewrite these areas as transducers we come out with the following code,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xml-extension-only&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;str/split&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="s"&gt;"\."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="s"&gt;"xml"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;files-only&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.isFile&lt;/span&gt; &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;as-path&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getAbsolutePath&lt;/span&gt; &lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;you should be able to see these transducer definitions are just restructured, single arity versions of our original &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; calls.&lt;/p&gt;&lt;p&gt;Now we need to turn these into a pipeline. We do this using the &lt;code&gt;comp&lt;/code&gt; function,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xform&lt;/span&gt; 
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="nv"&gt;files-only&lt;/span&gt; &lt;span class="nv"&gt;xml-extension-only&lt;/span&gt; &lt;span class="nv"&gt;as-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The use of &lt;code&gt;xform&lt;/code&gt; as a name is common in transducer examples (short for transform) so I have retained the use here for consistency. &lt;/p&gt;&lt;p&gt;With our transducers composed into a transform pipeline we can apply it to our input,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-xml-paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sequence&lt;/span&gt; &lt;span class="nv"&gt;xform&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-files&lt;/span&gt; &lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I redefined the &lt;code&gt;list-xml-paths&lt;/code&gt; function to call &lt;code&gt;sequence&lt;/code&gt; over the list of files and apply our transducer pipeline.&lt;/p&gt;&lt;p&gt;The complete code for this example looks like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;user&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.java.io&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;io&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.string&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;str&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
            
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-files&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file-seq &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;io/file&lt;/span&gt; &lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xml-extension-only&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;str/split&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="s"&gt;"\."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;last&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="s"&gt;"xml"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;files-only&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.isFile&lt;/span&gt; &lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;as-path&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.getAbsolutePath&lt;/span&gt; &lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xform&lt;/span&gt; 
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="nv"&gt;files-only&lt;/span&gt; &lt;span class="nv"&gt;xml-extension-only&lt;/span&gt; &lt;span class="nv"&gt;as-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;list-xml-paths&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sequence&lt;/span&gt; &lt;span class="nv"&gt;xform&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-files&lt;/span&gt; &lt;span class="nv"&gt;folder&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;xml-paths&lt;/span&gt; 
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list-xml-paths&lt;/span&gt; &lt;span class="s"&gt;"./workspace/xml"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;</content></entry><entry><title>Zombie Dice Score Card with Reagent</title><updated>Mon Jul 20 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/07/20/zombie-dice-score-card-with-reagent/"></link><id>urn:yobriefca-se:feed:post:Zombie Dice Score Card with Reagent</id><content type="html">&lt;p&gt;Over the weekend I built a &lt;a href="/zombie-dice"&gt;Zombie Dice Score Card&lt;/a&gt;. I built it because I keep forgetting to get pen and paper for keeping score but mostly because I wanted to build something simple in ClojureScript again.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/zombie-dice.png" alt="Zombie Dice Score Card" _="_" /&gt;&lt;/p&gt;&lt;p&gt;The app is pretty basic, no server side interaction, no local storage interaction and only a few basic actions/features. You simply,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Add players&lt;/li&gt;
  &lt;li&gt;Play zombie dice as usual, rewarding points by clicking the necessary brain on the screen.&lt;/li&gt;
  &lt;li&gt;When someone reaches 13 brains you'll be told to finish the round (all remaining players yet to go on this round have a final chance at stealing the win)&lt;/li&gt;
  &lt;li&gt;Hitting 'Finish Game' will reward the person with the highest number of brains a gold brain and the next game begins.&lt;/li&gt;
  &lt;li&gt;At any time you can reset the current game scores or clear the entire board.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;For the curious the stack used is as follows,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ClojureScript&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/martinklepsch/tenzing"&gt;Tenzing&lt;/a&gt; - Leiningen template for creating Boot powered client side only ClojureScript applications.&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://boot-clj.com/"&gt;Boot&lt;/a&gt; - The new build system on the Clojure(Script) block offering a more programatic approach to build systems (i.e more like Rake than Maven)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://reagent-project.github.io/"&gt;Reagent&lt;/a&gt; - A simple ClojureScript wrapper around &lt;a href="http://facebook.github.io/react/"&gt;React&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/lbradstreet/cljs-uuid-utils"&gt;cljs-uuid-utils&lt;/a&gt; - ClojureScript library for generating and working with UUID's&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Tenzing&lt;/h2&gt;&lt;p&gt;This is a nice little template for prototyping with ClojureScript or in situations where you can integrate with external services for your server side needs. It's a conditional template that lets you add technologies that you think you'll need. For example I generated the Zombie Dice Score Card project with,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;lein new tenzing zombie-dice +sass +reagent +divshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This template gives me an app with &lt;code&gt;SASS&lt;/code&gt;, &lt;code&gt;Reagent&lt;/code&gt; and &lt;a href="https://divshot.com/"&gt;Divshot&lt;/a&gt; configuration and all the necessary build pipeline stuff set up to compile CLJS and SASS when files change. I didn't use &lt;a href="https://divshot.com/"&gt;Divshot&lt;/a&gt; this time around but it's nice to know the option was there.&lt;/p&gt;&lt;p&gt;On another note I did find it a bit weird using Leiningen to generate a Boot application but I guess most Clojure(Script) developers are going to have Leiningen available and Boot doesn't provide templating support.&lt;/p&gt;&lt;h2&gt;Boot&lt;/h2&gt;&lt;p&gt;I didn't need to dive into Boot too much for this tiny project but I do like what I see. The way tasks are defined in Clojure and composed into pipelines using standard Clojure idioms makes creating build pipelines really rather nice.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;deftask&lt;/span&gt; &lt;span class="nv"&gt;build&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;speak&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cljs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sass&lt;/span&gt; &lt;span class="ss"&gt;:output-dir&lt;/span&gt; &lt;span class="s"&gt;"css"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;deftask&lt;/span&gt; &lt;span class="nv"&gt;run&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serve&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cljs-repl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You see &lt;code&gt;run&lt;/code&gt; composes a pipeline of other tasks for serving the application, watching for filesystem changes, connecting to a ClojureScript REPL and reloading the application. It then composes another defined task for building the ClojureScript and SASS.&lt;/p&gt;&lt;h2&gt;Reagent&lt;/h2&gt;&lt;p&gt;Aside from a name change Reagent (formerly Cloact) hasn't really change that much since I talked about in &lt;a href="https://yobriefca.se/blog/2014/01/18/adventures-in-clojure-land/"&gt;January 2014&lt;/a&gt;. Sure they've added some new features and refined the API a bit but its approach is still the same. It provides simple approach to using React in a ClojureScript app offering us hiccup style syntax for declaring components along side atoms for state management.&lt;/p&gt;&lt;p&gt;I've never really looked into the other React wrappers so I can't speak to whether Reagent is the best but I can say it's certainly been a pleasure to use on small scale apps.&lt;/p&gt;&lt;h2&gt;Source&lt;/h2&gt;&lt;p&gt;The source for the app is available, as always, on &lt;a href="https://github.com/kouphax/zombie-dice/"&gt;Github&lt;/a&gt; and I welcome any feedback or advice you may have.&lt;/p&gt;&lt;h2&gt;Plans&lt;/h2&gt;&lt;p&gt;I think I'm going to write this in Elm just to see what all the fuss is about. Maybe add some local storage for saving historical games and players. Truth be told I'll probably never touch it again but a man can dream.&lt;/p&gt;&lt;h2&gt;Footnote&lt;/h2&gt;&lt;p&gt;Have you ever played &lt;a href="http://www.sjgames.com/dice/zombiedice/"&gt;Zombie Dice&lt;/a&gt;? If not you should give it a go it's a simple, quick dice based game that you can explain in about 3 minutes and have a full game done in about 15 or 20 minutes. The aim is simple, try and collect/eat 13 brains by rolling dice over a series of rounds. Once someone hits 13 brains everyone finishes that round and the person that has the highest score wins that game. Typically you play best of 3 or 5 games.&lt;/p&gt;</content></entry><entry><title>Yesql - SQL in SQL in Clojure</title><updated>Tue Nov 25 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/11/25/yesql-sql-in-sql-in-clojure/"></link><id>urn:yobriefca-se:feed:post:Yesql - SQL in SQL in Clojure</id><content type="html">&lt;blockquote&gt;&lt;p&gt;Fair warning. This was initially a transcript for a yesql screencast I intended to do but time is dragging on and I really can't see myself getting to that any time soon.&lt;/p&gt;&lt;p&gt;Why does this matter?&lt;/p&gt;&lt;p&gt;Well I wouldn't be surprised if this reads pretty much like the yesql README.md with some minor embellishments here and there (and perhaps some opinion). But I'm putting it out there just, well, just because. Yesql is lovely and consider this a tribute of sorts.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;&lt;a href="https://github.com/krisajenkins/yesql"&gt;Yesql&lt;/a&gt; is a Clojure library for accessing SQL capable databases using SQL. Unlike its contemporaries yesql, as the name alludes to, embraces SQL. The argument here is why create a DSL, no matter how beautifully crafted, when we already have a perfect DSL already in the form of SQL.&lt;/p&gt;&lt;p&gt;To go a bit further lets look at the rationale in yesql's own README.&lt;/p&gt;&lt;p&gt;You could write your data access like this, as embedded SQL strings,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;query&lt;/span&gt; &lt;span class="s"&gt;"SELECT * FROM users WHERE country_code = ?"&lt;/span&gt; &lt;span class="s"&gt;"GB"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this doesn't scale very well,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;commands can get scattered about the code base,&lt;/li&gt;
  &lt;li&gt;its hard to see syntax errors, and,&lt;/li&gt;
  &lt;li&gt;longer statements can be difficult to read without any sort of syntax highlighting.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The next logical step taken to solve this problem is by adding an additional layer of abstraction. Language specific DSLs are created to dynamically build SQL.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;select &lt;/span&gt;&lt;span class="ss"&gt;:*&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;from&lt;/span&gt; &lt;span class="ss"&gt;:users&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;where&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="ss"&gt;:country_code&lt;/span&gt; &lt;span class="s"&gt;"GB"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The benefit these DSLs have is that they remove the need to know the specific dialect of SQL you're using. As each database has a slightly different SQL dialect you simply specify an adapter, such as PostgresAdapater) and the translated SQL will magically be Postgres compatible. Moving to a different database engine is a matter of specifying a new adapter with no code changes.&lt;/p&gt;&lt;p&gt;Sounds good right? Well not quite - as with almost all abstractions they start to break down when you tread off the happy path.&lt;/p&gt;&lt;p&gt;Every database system will likely have additional, non-core features, that you'll probably want to exploit, in fact these features are usually factored into selection criteria when you were deciding what to use. Postgres array and JSON data types are a good example of this. These are features that your clever DSL abstraction can't support without extra wrangling because they address the generality of problems. Suddenly you're back to writing raw sql for some of the queries and we are back where we started.&lt;/p&gt;&lt;p&gt;Yesql tackles these problems by putting SQL in SQL files and allows you to reference these blobs of SQL as clojure functions. So you'll lose the ability to execute the same code across different databases, which if my experience is anything to go by isn't the worst thing that can happen, but you'll gain better editor support, correct syntax highlighting and one less abstraction to ruin your mood.&lt;/p&gt;&lt;p&gt;Seeing it in action is the best way to demonstrate its simple but powerful api. We'll start by cloning a ready rolled project template&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;git clone -b 00-starting-point git@github.com:yobriefcasts/007-yesql.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is nothing more than a project generated by &lt;code&gt;lein new&lt;/code&gt; with 2 dependencies added,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;One is the Yesql library dependency itself, currently at version 0.4.0, and&lt;/li&gt;
  &lt;li&gt;The other is the h2 database driver which we will use as our database in these examples&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Finally we have a file based h2 database instance which is pre-populated with a people table containing a few rows of dummy data.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;1	James	Hughes	james@yobriefca.se
2	Emma	Hughes	emma@yobriefca.se
3	Ollie	Hughes	ollie@yobriefca.se
4	Nate	Hughes	nate@yobriefca.se
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;The First Query&lt;/h2&gt;&lt;p&gt;So lets get this data out of the database.&lt;/p&gt;&lt;p&gt;As is common across most SQL based libraries in Clojure Yesql derives its connections from a &lt;code&gt;db-spec&lt;/code&gt;. This is the same &lt;code&gt;db-spec&lt;/code&gt; map you'd pass Clojure's JDBC library or even korma. I'll provide &lt;a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html"&gt;a link&lt;/a&gt; to the relevant documentation if you want more information.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;db-spec&lt;/code&gt; required to connect to the current h2 database is already defined in the &lt;code&gt;core.clj&lt;/code&gt; file.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:classname&lt;/span&gt;    &lt;span class="s"&gt;"org.h2.Driver"&lt;/span&gt;
              &lt;span class="ss"&gt;:subprotocol&lt;/span&gt;  &lt;span class="s"&gt;"h2"&lt;/span&gt;
              &lt;span class="ss"&gt;:subname&lt;/span&gt;      &lt;span class="s"&gt;"./resources/demo.db"&lt;/span&gt;
              &lt;span class="ss"&gt;:user&lt;/span&gt;         &lt;span class="s"&gt;"sa"&lt;/span&gt;
              &lt;span class="ss"&gt;:password&lt;/span&gt;     &lt;span class="s"&gt;""&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So now if we want to create a SQL file &lt;code&gt;get-all-people.sql&lt;/code&gt; under the &lt;code&gt;src/sql&lt;/code&gt; directory we can write a simple &lt;code&gt;select *&lt;/code&gt; statement from the &lt;code&gt;people&lt;/code&gt; table.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sql"&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Its worth noting that the &lt;code&gt;sql&lt;/code&gt; folder name isn't necessary I simply used it for neatness. By default when calling &lt;a href="https://github.com/krisajenkins/yesql"&gt;Yesql&lt;/a&gt; - paths will be relative to the &lt;code&gt;src&lt;/code&gt; directory so you can organise it however you want.&lt;/p&gt;&lt;p&gt;Now we need to call this from our code. You'll notice in &lt;code&gt;core.clj&lt;/code&gt; that I have already included a single require for &lt;code&gt;defquery&lt;/code&gt; from the &lt;code&gt;yesql.core&lt;/code&gt; namespace.&lt;/p&gt;&lt;p&gt;&lt;code&gt;defquery&lt;/code&gt; is one of the 2 macros that gives you an entry point into &lt;a href="https://github.com/krisajenkins/yesql"&gt;Yesql&lt;/a&gt;, we will get to the other one shortly. &lt;code&gt;defquery&lt;/code&gt; takes a name and a path to the query file. This allows &lt;code&gt;defquery&lt;/code&gt; to parse the SQL file, convert it into a callable function and define a &lt;code&gt;var&lt;/code&gt; based on the name you've given it.&lt;/p&gt;&lt;p&gt;We can define our &lt;code&gt;get-all-people&lt;/code&gt; query like so,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defquery&lt;/span&gt; &lt;span class="nv"&gt;get-all-people&lt;/span&gt; &lt;span class="s"&gt;"sql/get-all-people.sql"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Although I've kept them the same the name of the file and the query name don't need to match. If we evaluate this line now we get back our &lt;code&gt;def&lt;/code&gt;'d function. Subsequent evaluations, for example if you've changed the contents of the SQL, will result in the &lt;code&gt;def&lt;/code&gt; being redefined.&lt;/p&gt;&lt;p&gt;If we call our new function as-is we'll get an error.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-all-people&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is because we also need to supply the &lt;code&gt;db-spec&lt;/code&gt; that was already defined for us. If we call the function correctly we should see our results.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-all-people&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lets give our output a bit more structure. We can import &lt;code&gt;clojure.pprint&lt;/code&gt;s &lt;code&gt;pprint&lt;/code&gt; function&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;yesql-tinkering.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;yesql.core&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;defquery&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.pprint&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;pprint&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And run our query again.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pprint&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-all-people&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Passing data to queries&lt;/h2&gt;&lt;p&gt;Executing static SQL isn't going to get you very far, if it does and you are only writing read-only systems with ready rolled queries - can I please come work with you? At the very least your queries often require &lt;code&gt;WHERE&lt;/code&gt; clauses that need to take values based on some user input from outside the database.&lt;/p&gt;&lt;p&gt;To demonstrate how we do this in &lt;a href="https://github.com/krisajenkins/yesql"&gt;Yesql&lt;/a&gt; lets add a new query that filters by surname. We can start by creating a new SQL file &lt;code&gt;src/sql/get-people-by-surname.sql&lt;/code&gt; and write our query. As with most frameworks that make use of parameterised queries we put token in place of the value we want to pass in, in the case of Yesql this can be a keyword that will associate a descriptive name against the argument..&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sql"&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;last_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;last_name&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next we can use the defquery macro to "realise" this query.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defquery&lt;/span&gt; &lt;span class="nv"&gt;get-people-by-surname&lt;/span&gt; &lt;span class="s"&gt;"sql/get-people-by-surname.sql"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can call this as we previous did except we need to pass it an argument for last_name.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pprint&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-people-by-surname&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="s"&gt;"Hughes"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Documentation&lt;/h2&gt;&lt;p&gt;Lets diverge a little from our path. Imagine a more complex SQL statement that accepts more than one argument, lets say it has a very domain specific name like &lt;code&gt;isolate_aggregated_upstream_resources&lt;/code&gt; - how would you 1. find out what this statement does and 2. how you would call it correctly? Well most obviously you could simply look at the SQL and work it out but that's not really an effective way to go about things.&lt;/p&gt;&lt;p&gt;In out last example SQL statement we used a parameter name of last_name, well this wasn't just for fun, if well look at the documentation for our query we can see that the parameter name is used as an argument name to our function&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.repl/doc&lt;/span&gt; &lt;span class="nv"&gt;get-people-by-surname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is handy but we can go one step further and supply &lt;code&gt;doc&lt;/code&gt; compatible documentation in our SQL in the form of comments. By prepending a comment on top of our SQL we can dive into supplying additional commentary around what this SQL is actually doing.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sql"&gt;&lt;span class="c1"&gt;-- Find all people for a given surname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we evaluate our &lt;code&gt;defquery&lt;/code&gt; again and look at the function signature we should see our comment available as a docstring.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.repl/doc&lt;/span&gt; &lt;span class="nv"&gt;get-people-by-surname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;yesql-tinkering.core/get-people-by-surname&lt;/span&gt;
&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;db&lt;/span&gt; &lt;span class="nv"&gt;last_name&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
  &lt;span class="nv"&gt;Find&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;people&lt;/span&gt; &lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;given&lt;/span&gt; &lt;span class="nv"&gt;surname&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Grouping queries&lt;/h2&gt;&lt;p&gt;The one file per query thing is all well and good until it isn't. You could rather quickly end up with a raft of folders with 3 or 4 queries each which is a bit of a pants way of arranging things.&lt;/p&gt;&lt;p&gt;Yesql provides a way to group similar queries in a single file, well they don't &lt;strong&gt;have&lt;/strong&gt; to be similar but lets assume we have some logical grouping here.&lt;/p&gt;&lt;p&gt;So lets add a few accessor methods for getting people out of our database. If we create a SQL file &lt;code&gt;src/sql/get-persons.sql&lt;/code&gt; and add 2 queries, one for getting a user by ID and another for getting a user by email address. When you use &lt;code&gt;defquery&lt;/code&gt; you specify the name of the function in the declaration and the entire file is used as a basis for the query however when we are defining multiple queries at once we need both logically separate the queries in the file and associate a name with each one. We do this by adding a structured comment above each query starting with &lt;code&gt;name:&lt;/code&gt; and followed by the name you want to refer to the query as in your code.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sql"&gt;&lt;span class="c1"&gt;-- name: get-person-by-id&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;

&lt;span class="c1"&gt;-- name: get-person-by-email&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;email_address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;email_address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To define these queries in our code we need to import the other macro in &lt;code&gt;yesql&lt;/code&gt;s arsenal &lt;code&gt;defqueries&lt;/code&gt;. We can then use this to import our queries,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defqueries&lt;/span&gt; &lt;span class="s"&gt;"sql/get-persons.sql"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You'll notice that &lt;code&gt;defqueries&lt;/code&gt; returns a vector of the defined functions and we can see our two function handles. We can call each of these in the usual way.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-person-by-id&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-person-by-email&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="s"&gt;"james@yobriefca.se"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Non-Queries&lt;/h2&gt;&lt;p&gt;We've still only dealt with querying our database but most systems usually need to manipulate the contained data by either writing new rows or updating and deleting existing rows.&lt;/p&gt;&lt;p&gt;Rather than add a new set of macros - &lt;a href="https://github.com/krisajenkins/yesql"&gt;yesql&lt;/a&gt; uses naming conventions to signal to the macros that the operation is a non-query operation.&lt;/p&gt;&lt;p&gt;For example if we create a SQL file containing a statement for inserting a new user that expects &lt;code&gt;first_name&lt;/code&gt;, &lt;code&gt;last_name&lt;/code&gt; and &lt;code&gt;email_address&lt;/code&gt;, the database will auto generate our ID value.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sql"&gt;&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;email_address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;values&lt;/span&gt;&lt;span class="p"&gt;(:&lt;/span&gt;&lt;span class="n"&gt;first_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;last_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;email_address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use &lt;code&gt;defquery&lt;/code&gt; again to create our function except this time we prepend the name with an exclamation mark. This is the marker to tell yesql that this is a statement rather than a query.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defquery&lt;/span&gt; &lt;span class="nv"&gt;insert-person!&lt;/span&gt; &lt;span class="s"&gt;"sql/insert-person.sql"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function expects the usual &lt;code&gt;db-spec&lt;/code&gt; object as well as our arguments&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.repl/doc&lt;/span&gt; &lt;span class="nv"&gt;insert-person!&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we can call it in the normal way.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-person!&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="s"&gt;"Bill"&lt;/span&gt; &lt;span class="s"&gt;"Thompson"&lt;/span&gt; &lt;span class="s"&gt;"bill@thompson.com"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This style can be used with any non-query statement such as &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;alter&lt;/code&gt; and all those other statements your database engine supports.&lt;/p&gt;&lt;p&gt;Statements will return the number of rows affected by default however in the case of insert statements against tables that have auto-generated ids you may want the id of the newly inserted row returned instead. You can achieve this in &lt;a href="https://github.com/krisajenkins/yesql"&gt;yesql&lt;/a&gt; with the less than exclamation (&lt;code&gt;&amp;lt;!&lt;/code&gt;) instead. If we we redefine our &lt;code&gt;insert-person!&lt;/code&gt; function to use this we can see that it will return a different set of information&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defquery&lt;/span&gt; &lt;span class="nv"&gt;insert-person&amp;lt;!&lt;/span&gt; &lt;span class="s"&gt;"sql/insert-person.sql"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-person&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;db-spec&lt;/span&gt; &lt;span class="s"&gt;"Emma"&lt;/span&gt; &lt;span class="s"&gt;"Thompson"&lt;/span&gt; &lt;span class="s"&gt;"emma@thompson.com"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What is actually returned depends on the database engine, h2 returns a map containing the id but some engines return the full row.&lt;/p&gt;&lt;h2&gt;Wrap Up&lt;/h2&gt;&lt;p&gt;Thats just about covers the main features of &lt;a href="https://github.com/krisajenkins/yesql"&gt;yesql&lt;/a&gt; which as you can see is a neat little solution to bridging the gap between the database and your code. It avoids all the normal pain of wrangling with other peoples conventions and leaky abstractions and allows you to use SQL directly which is a much better medium to express queries against relational data stores.&lt;/p&gt;</content></entry><entry><title>Functional Programming with Clojure</title><updated>Tue Sep 23 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="/presentations/functional-programming-with-clojure.pdf"></link><id>urn:yobriefca-se:feed:post:Functional Programming with Clojure</id><content type="html"></content></entry><entry><title>Simple stubbing with lein-cooper and lein-oneoff</title><updated>Tue Aug 26 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/08/26/simple-stubbing-with-lein-cooper-and-lein-oneoff/"></link><id>urn:yobriefca-se:feed:post:Simple stubbing with lein-cooper and lein-oneoff</id><content type="html">&lt;p&gt;Work on &lt;a href="https://github.com/kouphax/lein-cooper"&gt;lein-cooper&lt;/a&gt; has been pretty quiet. It's not because it has been abandoned but because it does enough for my needs. As and when it starts getting issues or pull requests coming in I can start adapting it to fit the wider needs of others.&lt;/p&gt;&lt;p&gt;Recently I came across a lovely leiningen plugin called &lt;a href="https://github.com/mtyaka/lein-oneoff"&gt;&lt;code&gt;lein-oneoff&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;oneoff&lt;/code&gt; allows you to specify dependencies for a clojure script at the top of a clojure script (a bit like what &lt;a href="http://groovy.codehaus.org/Grape"&gt;Grape&lt;/a&gt; does in the Groovy world I believe). This means you don't have to spin up all the project infrastructure to run a simple script. So instead of &lt;code&gt;lein new server&lt;/code&gt; and editing the &lt;code&gt;core.clj&lt;/code&gt; file to mock up a simple "Hello World" sample you could do something like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defdeps&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojure&lt;/span&gt; &lt;span class="s"&gt;"1.6.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring/ring-jetty-adapter&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring&lt;/span&gt; &lt;span class="s"&gt;"1.3.1"&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;server&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring.adapter.jetty&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;run-jetty&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;handler&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;request&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:status&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;
   &lt;span class="ss"&gt;:headers&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Content-Type"&lt;/span&gt; &lt;span class="s"&gt;"text/html"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="ss"&gt;:body&lt;/span&gt; &lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-jetty&lt;/span&gt; &lt;span class="nv"&gt;handler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:port&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If this were saved as &lt;code&gt;server.clj&lt;/code&gt; we could use &lt;code&gt;lein-oneoff&lt;/code&gt; (declared in the global &lt;code&gt;~/.lein/profiles.clj&lt;/code&gt;) to run it like so,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;&amp;gt; lein oneoff server.clj
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice the &lt;code&gt;defdeps&lt;/code&gt; form at the top of the file, this will be used to grab dependencies and set up the appropriate classpath for running the script.&lt;/p&gt;&lt;p&gt;Pretty neat.&lt;/p&gt;&lt;p&gt;I also noticed that this would be a perfect accompaniment for a typical usage of &lt;code&gt;lein-cooper&lt;/code&gt; - &lt;strong&gt;stubbing out external services&lt;/strong&gt;. If you're building a system that integrates with other services (either internal or external) you introduce a bit of friction when it comes to developing and testing (at the integration level at least) your system. Either you have to build and run dependent services or rely on external services that may or may not be available. A simple solution is to develop against simple stubs for these services. This is what &lt;code&gt;coop-off&lt;/code&gt; (the new power couple portmanteau I've given to the &lt;code&gt;lein-cooper&lt;/code&gt;/&lt;code&gt;lein-oneoff&lt;/code&gt; combination) can make easier.&lt;/p&gt;&lt;p&gt;Just create a &lt;code&gt;stubs&lt;/code&gt; folder in your project, create standalone service stubs (like the example below that also demonstrates the use of &lt;code&gt;oneoff&lt;/code&gt;s &lt;code&gt;*command-line-args*&lt;/code&gt; for accessing arguments passed with the command),&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defdeps&lt;/span&gt;
  &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojure&lt;/span&gt; &lt;span class="s"&gt;"1.6.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring/ring-jetty-adapter&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/data.json&lt;/span&gt; &lt;span class="s"&gt;"0.2.5"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring&lt;/span&gt; &lt;span class="s"&gt;"1.3.1"&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;server&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;ring.adapter.jetty&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;run-jetty&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.data.json&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;json&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;handler&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;request&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:status&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;
    &lt;span class="ss"&gt;:headers&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Content-Type"&lt;/span&gt; &lt;span class="s"&gt;"application/json"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="ss"&gt;:body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;json/write-str&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:success&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="ss"&gt;:data&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;port&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Integer.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first &lt;/span&gt;&lt;span class="nv"&gt;*command-line-args*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;start-server&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;port&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;run-jetty&lt;/span&gt; &lt;span class="nv"&gt;handler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:port&lt;/span&gt; &lt;span class="nv"&gt;port&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;start-server&lt;/span&gt; &lt;span class="nv"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And you can integrate the running of this and other stubs alongside using &lt;code&gt;lein-cooper&lt;/code&gt;. Just create a &lt;code&gt;Procfile&lt;/code&gt; for &lt;code&gt;lein-cooper&lt;/code&gt; with commands to run everything,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;web: lein ring server
data: lein oneoff stubs/data.clj 3000
auth: lein oneoff stubs/auth.clj 3002
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally run the whole thing via &lt;code&gt;lein cooper&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;The standalone stubs will be executed alongside your own service without the overhead of having to manage separate projects or integrate test code into your own project.&lt;/p&gt;</content></entry><entry><title>A Case for Luminus</title><updated>Mon Jul 21 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/07/21/a-case-for-luminus/"></link><id>urn:yobriefca-se:feed:post:A Case for Luminus</id><content type="html">&lt;p&gt;First and foremost - frameworks. I view frameworks suspiciously and prefer to &lt;a href="http://yobriefca.se/blog/2014/01/04/building-systems-libraries-and-frameworks/"&gt;build my systems&lt;/a&gt; out of a core set of libraries and allow it to evolve and breathe a little without the artificial constraints of a framework. There is a time and place for frameworks, but that time and place never seems to be here and now were my work is concerned. This may be one of the many reasons I find Clojure so enjoyable.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; is a "Clojure web framework". It says so right on the the tagline of the &lt;a href="http://www.luminusweb.net/"&gt;Luminus homepage&lt;/a&gt;. This single line has meant I have hesitated diving into Luminus since I starting breaking the back of my Clojure dabbling. I wanted to avoid it until I felt it useful or necessary to invest my time in it, a framework, after-all, needs to be understood as a whole unlike its modular library counterparts.&lt;/p&gt;&lt;p&gt;So my first foray into building web apps in Clojure meant building them out from scratch using a foundation of Ring, Compojure, Hiccup - the usual suspects. Data access meant looking at a few possibilities , assessing each one and making a decision. Various authentication libraries needed thorough inspections. This, as you can expect, leads to a tremendous amount of yak-shaving and time spent satisfying curiosity.&lt;/p&gt;&lt;p&gt;So I had a look at &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt;. I wanted to see what decisions a framework had made and possibly steal some of the better ideas. I used &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; on my next project. I didn't steal the good ideas for my own work, I didn't need to - the image I have in my head when someone mentions framework is simply not what &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; is. &lt;/p&gt;&lt;p&gt;In its most basic form a framework is a collection of 3rd party and bespoke libraries tied together with some code that abstracts the library specifics into a more cohesive whole. &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; doesn't really have this. There is no bespoke modules or libraries, there is no abstraction. &lt;a href="https://clojars.org/search?q=luminus"&gt;Clojars&lt;/a&gt; has no &lt;code&gt;luminus&lt;/code&gt; library. It does have a Leiningen &lt;a href="https://clojars.org/luminus/lein-template"&gt;template&lt;/a&gt; that gives you a decent starting point but even that isn't even a heavily opinionated starting point and can be &lt;a href="http://www.luminusweb.net/docs/profiles.md"&gt;customised&lt;/a&gt; to suit your own needs.&lt;/p&gt;&lt;p&gt;So what is Luminus? IMHO Luminus is what you'd end up with if you wanted to personally build a curated list of recommended libraries to build web applications in Clojure. It's what would happen if you bothered to document that process and offer alternatives. In fact while the curated set of libraries makes for a productive development process with reduced decision anxiety it's the documentation that launches it out of the park. Rather than "Do it like this", the documentation offers recommendations and guides for using alternative libraries such as &lt;a href="http://www.luminusweb.net/docs/migrations.md"&gt;migrations&lt;/a&gt;, data access, &lt;a href="http://www.luminusweb.net/docs/html_templating.md"&gt;HTML templating&lt;/a&gt; and &lt;a href="http://www.luminusweb.net/docs/security.md"&gt;authentication&lt;/a&gt;. &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; gives you enough to get started and generously gives you a foot up to the next level. &lt;/p&gt;&lt;p&gt;At no point in time does &lt;a href="http://www.luminusweb.net/"&gt;Luminus&lt;/a&gt; hide anything from you, it wears its lineage as a badge of honour and won't get offended if you decide it's wrong in places. &lt;/p&gt;&lt;p&gt;I can respect that.&lt;/p&gt;</content></entry><entry><title>Publish and Subscribe with core.async's pub and sub</title><updated>Wed Jun 04 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/"></link><id>urn:yobriefca-se:feed:post:Publish and Subscribe with core.async's pub and sub</id><content type="html">&lt;p&gt;Following on from my &lt;a href="/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"&gt;previous article&lt;/a&gt; that covered &lt;code&gt;core.async&lt;/code&gt;'s &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; this article will delve into another suite of complementary &lt;strong&gt;high level&lt;/strong&gt; methods - namely the channel driven publish/subscribe model that &lt;code&gt;core.async&lt;/code&gt; can support.&lt;/p&gt;&lt;p&gt;While the pub/sub mechanism provided by core.async is higher level than working directly with &lt;code&gt;chan&lt;/code&gt;s and &lt;code&gt;mult&lt;/code&gt;s to achieve the same thing (in fact that is how the pub/sub operations are implemented internally) it should still be considered a set of lower level primitives compared to say a specific event bus notification with topic namespacing, wildcard broadcasting and other such specialised features.&lt;/p&gt;&lt;p&gt;I've attempted to visualise how the various parts of a pub/sub setup would interact. We'll use this as a starting point and expand on how this all falls together through the course of the article.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/pubsub.png" alt="Pub Sub" _="_" /&gt;&lt;/p&gt;&lt;h2&gt;Setup&lt;/h2&gt;&lt;p&gt;Once again we'll use ClojureScript to demonstrate the use of pub/sub. I'll refer you the &lt;strong&gt;Setting Up&lt;/strong&gt; section of my &lt;a href="/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"&gt;previous article&lt;/a&gt; if you want to get a basic ClojureScript setup running with &lt;code&gt;core.async&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;Publishing&lt;/h2&gt;&lt;p&gt;Channels are &lt;code&gt;core.async&lt;/code&gt;s foundation and this is no different when you move up a level of abstraction to a pub/sub model. Looking at the publishing side first there are 2 main types of actors or components involved,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The publisher channel - Putting stuff on this channel will cause the publishing mechanism to kick in&lt;/li&gt;
  &lt;li&gt;The publication - calling &lt;code&gt;pub&lt;/code&gt; on the publisher (we'll see this in a minute) produces a &lt;code&gt;publication&lt;/code&gt; that subscribers can &lt;code&gt;sub&lt;/code&gt;/subscribe to.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;This may appear a bit more jarring than a typical approach where you just have a monolithic pub/sub object (e.g. a bus) that you publish and subscribe to directly. However I found the idea a bit easier to understand when I thought of the publication as a realised &lt;strong&gt;topic&lt;/strong&gt; or set of &lt;strong&gt;topics&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;If you think of a simple message bus implementation (in whatever language floats your boat - I've went with Swift, nah just kidding its JavaScript) you would traditionally do something like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="javascript"&gt;&lt;span class="c1"&gt;// grab/create a bus - typically global.&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;bus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Bus&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nx"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"account:created"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
  &lt;span class="c1"&gt;// do something with the knowledge that&lt;/span&gt;
  &lt;span class="c1"&gt;// an account has been created&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;// at some point we publish to the same topic&lt;/span&gt;
&lt;span class="nx"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"acoount:created"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;success&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nx"&gt;username&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"petedaleet17"&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The topic in this example is &lt;code&gt;account:created&lt;/code&gt; however in reality its just a string, there is no real confidence that you are achieving what you expect. A spelling error will result in rather unpredictable results and as we have introduced a high degree of decoupling it may well be difficult to track down. The observant will notice there is in fact a spelling error in the code.&lt;/p&gt;&lt;p&gt;In &lt;code&gt;core.async&lt;/code&gt; the notion of a &lt;code&gt;publication&lt;/code&gt; is a realised entity you perform actions on and pass around. It's the transport mechanism, that is the "concept". This inversion is interesting. 99.9% of the time I'm ultimately interested in publishing or subscribing to a topic, I really don't care about the mechanics of that operation and this &lt;strong&gt;topic-first&lt;/strong&gt; view better supports that thought model.&lt;/p&gt;&lt;p&gt;Now just to confuse things a bit more, a publication also defines a way to derive the topic of a published value so its entirely possible for a publication to handle subscriptions for any number of topics. Another analogy that may help, or just make things worse, is that a &lt;code&gt;publication&lt;/code&gt; could be considered a &lt;code&gt;router&lt;/code&gt; that defines a set of rules for where to publish data.&lt;/p&gt;&lt;p&gt;To expand on this lets look at some code.&lt;/p&gt;&lt;p&gt;First we need to import a few things into out ClojureScript file (probably &lt;code&gt;core.cljs&lt;/code&gt;)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;chat.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;chan&lt;/span&gt; &lt;span class="nv"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;timeout&lt;/span&gt; &lt;span class="nv"&gt;pub&lt;/span&gt; &lt;span class="nv"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;unsub&lt;/span&gt; &lt;span class="nv"&gt;unsub-all&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require-macros&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async.macros&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;go&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets introduce our publisher and our publication,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; publisher is just a normal channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; publication is a thing we subscribe to&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;publication&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pub&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see the &lt;code&gt;publisher&lt;/code&gt; is simply a channel, no fancy annotations or extra functions being applied. It's just a vanilla channel that you can put stuff and take stuff off if you so desired.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;publication&lt;/code&gt; ont he other hand is composed by calling &lt;code&gt;pub&lt;/code&gt; on &lt;code&gt;publisher&lt;/code&gt; passing a function. When you put stuff onto &lt;code&gt;publisher&lt;/code&gt; this function is used to derive the topic of the data put onto the channel. It will get passed the put data and is expected to return &lt;strong&gt;something&lt;/strong&gt;, &lt;strong&gt;anything&lt;/strong&gt; that represents the topic.&lt;/p&gt;&lt;p&gt;In this case I am making an assumption that our data will be a map with a &lt;code&gt;:topic&lt;/code&gt; entry. Of course if &lt;code&gt;(:topic data)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; that will be our topic. Any topics that have no subscribers will be disregarded so &lt;code&gt;nil&lt;/code&gt; will typically be an acceptable &lt;strong&gt;dead letter office&lt;/strong&gt; so to speak.&lt;/p&gt;&lt;h2&gt;Subscribing&lt;/h2&gt;&lt;p&gt;So now we have something we can push data onto - the &lt;code&gt;publisher&lt;/code&gt; channel, and something that will accept subscriptions - the &lt;code&gt;publication&lt;/code&gt;. Next we need to subscribe and start putting stuff on that our subscribers can consume. We could start putting stuff on the channel now but no one will be around to receive it just yet.&lt;/p&gt;&lt;p&gt;The yin to &lt;code&gt;pub&lt;/code&gt;s yang is &lt;code&gt;sub&lt;/code&gt;. &lt;code&gt;sub&lt;/code&gt; always takes a &lt;strong&gt;publication&lt;/strong&gt;, a &lt;strong&gt;topic&lt;/strong&gt; and a &lt;strong&gt;channel&lt;/strong&gt; (you can also specify how and when the subscribing channel will be closed). As I've already mentioned you'll notice that the subscriber channels don't subscribe directly to the publisher channel. This would allow you to create many publications from a single source channel.&lt;/p&gt;&lt;p&gt;Taking our previous example we could subscribe to a number of topics like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; define a bunch of subscribers&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-one&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-two&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; subscribe&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt;  &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt;     &lt;span class="nv"&gt;subscriber-three&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We now have 3 channels&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;subscriber-one&lt;/code&gt; is subscribed to the &lt;code&gt;:account-created&lt;/code&gt; topic&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;subscriber-two&lt;/code&gt; is subscribed to both the &lt;code&gt;:account-created&lt;/code&gt; topic and the &lt;code&gt;:user-logged-in&lt;/code&gt; topic&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;subscriber-three&lt;/code&gt; is subscribed to the &lt;code&gt;:change-page&lt;/code&gt; topic&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Now when messages are put on to the &lt;code&gt;publisher&lt;/code&gt; the &lt;code&gt;publication&lt;/code&gt; will inspect the data and determine where to route the message. To make this more visual we can listen to and print the values from these channels by trying to take from them in a &lt;code&gt;go-loop&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;take-and-print&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go-loop&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;prefix&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-one&lt;/span&gt; &lt;span class="s"&gt;"subscriber-one"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt; &lt;span class="s"&gt;"subscriber-two"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-three&lt;/span&gt; &lt;span class="s"&gt;"subscriber-three"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we start putting messages on the publisher we should see some console output.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt; &lt;span class="ss"&gt;:dest&lt;/span&gt; &lt;span class="s"&gt;"/#home"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-three: { :topic :change-page :dest "/#home" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-one: { :topic :account-created :username "billy" }&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-two: { :topic :account-created :username "billy" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-two: { :topic :user-logged-in :username "billy" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-out&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; No subscribers so nothing to see&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course subscribing to something is entirely additive. You need some way to take subscriptions away. At this point &lt;code&gt;unsub&lt;/code&gt; and &lt;code&gt;unsub-all&lt;/code&gt; are what you need.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; unsubscribe subscriber-two from account-created&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-one: { :topic :account-created :username "billy" }&lt;/span&gt;

&lt;span class="c1"&gt;; unsubscribe every subscriber from the :account-created topic&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub-all&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; nada&lt;/span&gt;

&lt;span class="c1"&gt;; finally unsubscribe every channel from every topic&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub-all&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt; &lt;span class="ss"&gt;:dest&lt;/span&gt; &lt;span class="s"&gt;"/#home"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-out&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; wonderful silence&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;So that covers the &lt;code&gt;pub&lt;/code&gt;/&lt;code&gt;sub&lt;/code&gt; model you get with &lt;code&gt;core.async&lt;/code&gt; which gives a slightly higher abstraction from having to deal with the internal logic of managing a &lt;code&gt;mult&lt;/code&gt; to perform this operation while still remaining suitably low level to allow you to build upon it for your own needs.&lt;/p&gt;&lt;p&gt;Remember that because everything still boils down to channels, which you have access to, there is huge potential to combine various abstractions to construct simple pipelines for all your needs.&lt;/p&gt;&lt;p&gt;One day I'll finish my channel based &lt;a href="https://en.wikipedia.org/wiki/Rube_Goldberg_machine"&gt;Rube Goldberg machine&lt;/a&gt; put a message at one end and watch as it gets piped through mults, publications, merged channels, alts and anything else I can think of finally ending up in a &lt;code&gt;console.log&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;"Hi James".&lt;/p&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Combining &amp; Controlling Channels with core.async's merge and mix</title><updated>Sun Jun 01 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"></link><id>urn:yobriefca-se:feed:post:Combining &amp; Controlling Channels with core.async's merge and mix</id><content type="html">&lt;p&gt;Most discussions around &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt;, be it in Clojure or ClojureScript, tend to focus around the key concepts of the library - specifically &lt;code&gt;chan&lt;/code&gt;s and the &lt;code&gt;go&lt;/code&gt;/&lt;code&gt;go-loop&lt;/code&gt; macros. This isn't a bad thing as that is were the power of the library comes from, on the other hand &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt; also has a few powerful higher-level features that let you do some very interesting things and they deserve a bit of love as well.&lt;/p&gt;&lt;p&gt;Two such features are &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/merge"&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/mix"&gt;&lt;code&gt;mix&lt;/code&gt;&lt;/a&gt;. Both methods have a similar goal - combining multiple input channels into a single output channel however in practise they are rather different.&lt;/p&gt;&lt;p&gt;At a high level you could draw the 2 operations like so,&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/mix-merge.png" alt="High level view of merge and mix" _="_" /&gt;&lt;/p&gt;&lt;p&gt;In fact the &lt;code&gt;mix&lt;/code&gt; diagram is slightly more complicated in reality but we can expand on that as we go.&lt;/p&gt;&lt;h2&gt;Setting up&lt;/h2&gt;&lt;p&gt;So lets look at some examples of these operations. I'm talking in the context of ClojureScript in this case but same reules and principles apply in plain Clojure.&lt;/p&gt;&lt;p&gt;If you want to try these examples and are rather new to ClojureScript I recently outlined a &lt;a href="http://yobriefca.se/blog/2014/05/30/basic-clojurescript-setup/"&gt;basic ClojureScript setup&lt;/a&gt; which will get you up and running.&lt;/p&gt;&lt;p&gt;Assuming you have an empty ClojureScript project one way or another you need to add a reference to &lt;code&gt;core.async&lt;/code&gt; in the &lt;code&gt;:dependencies&lt;/code&gt; section of the projects &lt;code&gt;project.clj&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;  &lt;span class="ss"&gt;:dependencies&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojurescript&lt;/span&gt; &lt;span class="s"&gt;"0.0-2173"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/core.async&lt;/span&gt; &lt;span class="s"&gt;"0.1.303.0-886421-alpha"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then in your ClojureScript source (probably &lt;code&gt;src/&amp;lt;project_name&amp;gt;/core.cljs&lt;/code&gt;) you need to import a few things. I'll assume you have at least a basic understanding of channels and &lt;code&gt;core.async&lt;/code&gt; already so we can just import everything we need for the examples.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;chat.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mix&lt;/span&gt; &lt;span class="nv"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;toggle&lt;/span&gt; &lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="nv"&gt;chan&lt;/span&gt; &lt;span class="nv"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require-macros&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async.macros&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;go&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we are about ready for the examples.&lt;/p&gt;&lt;h2&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/merge"&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; is the simpler of the two features and as the API documentation says combines 1..N source channels and returns a channel which contains all values taken from them. The operation is entirely immutable. That is, once you use &lt;code&gt;merge&lt;/code&gt; to create a channel you can't add or remove channels later. When all input channels have closed the merged channel will also close.&lt;/p&gt;&lt;p&gt;This is useful when you have multiple event streams, represented as channels, and you want to process them in the same way and in a centralised manner e.g. when you are wanting to parse multiple simultaneous server requests, web socket events or user interactions from various parts of the user interface.&lt;/p&gt;&lt;p&gt;To keep the example simple we will just create 3 channels that randomly publish their names every now and then,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; declare the channels&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-one&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-two&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; define the function for publishing&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;randomly-constantly&lt;/span&gt;
  &lt;span class="s"&gt;"Constantly publishes the given value to the given channel in random&lt;/span&gt;
&lt;span class="s"&gt;   intervals every 0-5 seconds."&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;publish-value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;timeout&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rand-int &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;publish-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;; start putting stuff on the channels&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;   &lt;span class="s"&gt;"channel-one"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;   &lt;span class="s"&gt;"channel-two"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt; &lt;span class="s"&gt;"channel-three"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So now we have 3 channels that will randomly have their name pushed onto them we now need to do something with them. For the sake of simplicity lets assume all we need to do is log the result. We could write 3 distinct &lt;code&gt;go&lt;/code&gt; loops (or suitably abstract it into a reusable function),&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But regardles of how much you abstract away the mechanics you are still dealing with the 3 channels as 3 distinct entities when in many cases you should be dealing with a single channel derived from multiple sources. We achieve this with &lt;code&gt;merge&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;merged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-channel-one&lt;/span&gt;
                    &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;
                    &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;merged&lt;/code&gt; is now a channel that we can &lt;code&gt;take&lt;/code&gt; from and recieve values from all 3 channels. Now we can perform our &lt;code&gt;go&lt;/code&gt; loop over the single channel instead,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;merged&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/mix"&gt;&lt;code&gt;mix&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; is fine when you want to just grab a bunch of channels and treat them as one but sometimes this is not enough. When it comes to channels that produce effects visible to the user there is often a need to better control these messages. Imagine a chat application where each person is represented as a channel, or perhaps a log dashboard where each channel is a service in your system streaming log data.&lt;/p&gt;&lt;p&gt;In such situations, where the volume is high, there may be times you want to focus on a particular set of logs or chat messages, or surpress someone or something that is being particularly chatty. Maybe these messages can be discarded, maybe they are important and need to looked at later. These are the things that &lt;code&gt;merge&lt;/code&gt; fails to address. These are the things that &lt;code&gt;mix&lt;/code&gt; &lt;strong&gt;does&lt;/strong&gt; address.&lt;/p&gt;&lt;p&gt;The key differences that set &lt;code&gt;mix&lt;/code&gt; apart from &lt;code&gt;merge&lt;/code&gt; are that,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It introduces an intermediary component - the mixer&lt;/li&gt;
  &lt;li&gt;It is configurable, you can add and remove input channels&lt;/li&gt;
  &lt;li&gt;Channels can be muted, paused and solo'ed on demand&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;So lets take our 3 channels above and apply the abilities of &lt;code&gt;mix&lt;/code&gt; to the situation.&lt;/p&gt;&lt;p&gt;First of all we need to create 2 things.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The output channel - unlike &lt;code&gt;merge&lt;/code&gt; this isn't created for us&lt;/li&gt;
  &lt;li&gt;The mixer - we create this via the &lt;code&gt;mix&lt;/code&gt; method&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; manually declare our output channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;output-channel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; create a mixer linked to the output channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;mix&lt;/span&gt; &lt;span class="nv"&gt;output-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also, at this point, set up our &lt;code&gt;go&lt;/code&gt; loop for printing the data put onto the output channel&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;output-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike &lt;code&gt;merge&lt;/code&gt; we still haven't declared what input channels should be associated with the mixer and ultimately output channel. We can do this using &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/admix"&gt;&lt;code&gt;admix&lt;/code&gt;&lt;/a&gt;,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point we should start seeing stuff being logged to the console exactly like we did with &lt;code&gt;merge&lt;/code&gt;. This is where &lt;code&gt;mix&lt;/code&gt; starts to get interesting.&lt;/p&gt;&lt;h3&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/toggle"&gt;&lt;code&gt;toggle&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;toggle&lt;/code&gt; allows you to control how the mixer responds to each input channel. You pass it a state map of channels and associated mixer properties. With &lt;code&gt;toggle&lt;/code&gt; you can do any combination (though many would not make sense) of,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;:mute&lt;/code&gt; - keep taking from the input channel but discard any taken values&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:pause&lt;/code&gt; - stop taking from the input channel&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:solo&lt;/code&gt; - listen &lt;strong&gt;only&lt;/strong&gt; to this (and other &lt;code&gt;:solo&lt;/code&gt;ed channels). Whether or not the non-soloed channels are muted or paused can be controlled via the &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/solo-mode"&gt;&lt;code&gt;solo-mode&lt;/code&gt;&lt;/a&gt; method.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;So lets imagine one of our mixed channels (&lt;code&gt;in-channel-one&lt;/code&gt;) it getting a bit chatty. It could swamp our logging output and we might miss something important in another channel. We can use toggle to temporarily mute it,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:mute&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now our output will only be displaying the other 2 channels. But suppose the data coming in from channel one was actually important, as it stands muting a channel simply discards any takes that happen. If we want to stop taking anything from the channel (and therefore allow it to buffer on the channel) we can pause the channel instead.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:mute&lt;/span&gt;  &lt;span class="nv"&gt;false&lt;/span&gt;
                                 &lt;span class="ss"&gt;:pause&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally if we want to &lt;strong&gt;only&lt;/strong&gt; concern ourselves with channel one we can &lt;code&gt;solo&lt;/code&gt; it&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:solo&lt;/span&gt;  &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You'll notice I didn't set &lt;code&gt;:pause&lt;/code&gt; back to &lt;code&gt;false&lt;/code&gt; because soloed channels ignore their other properties..&lt;/p&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;We covered both the &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; methods of &lt;code&gt;core.async&lt;/code&gt;. Both methods are higher level ways to combine and control multiple input channels into a single unified output channel.&lt;/p&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; offers a simple straigthforward way to combine channels but offers you little control after the fact. &lt;code&gt;mix&lt;/code&gt; gives you greater control over the input channels and is exceptionally useful when you need to manage input streams.&lt;/p&gt;</content></entry><entry><title>Basic ClojureScript Setup</title><updated>Fri May 30 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/05/30/basic-clojurescript-setup/"></link><id>urn:yobriefca-se:feed:post:Basic ClojureScript Setup</id><content type="html">&lt;p&gt;ClojureScript is a bit of an awkward one to get into. If Clojure isn't your natural language then you may well find the clojarian setup and the long compilation times a bit of a frustration. Even if you're accustomed to the REPL based development approach that fits so well with Clojure there is still a certain amount of friction to be had with ClojureScript.&lt;/p&gt;&lt;p&gt;Recently a strong desire to play with and better understand &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt; in ClojureScript I decided to try and put together a lightweight workflow. In doing so I ended up producing a Clojure library (&lt;a href="http://yobriefca.se/primrose/"&gt;primrose&lt;/a&gt;) and a Leiningen plugin (&lt;a href="http://yobriefca.se/lein-cooper/"&gt;lein-cooper&lt;/a&gt;) to better support this workflow.&lt;/p&gt;&lt;p&gt;It's probably a sure sign that you are doing something wrong when you feel you need to create a bunch of developer focused tools to support a workflow for an already established ecosystem but you gotta do, what you gotta do.&lt;/p&gt;&lt;p&gt;Here goes.&lt;/p&gt;&lt;h2&gt;Starting point&lt;/h2&gt;&lt;p&gt;ClojureScript projects are still Clojure projects and so there are few bits and pieces that you need to wire up a basic empty project. You've got your &lt;code&gt;project.clj&lt;/code&gt;, the &lt;a href="https://github.com/emezeske/lein-cljsbuild"&gt;&lt;code&gt;lein-cljsbuild&lt;/code&gt;&lt;/a&gt; plugin for compiling ClojureScript to JavaScript and (at the very least) an &lt;code&gt;index.html&lt;/code&gt; for bringing everything together.&lt;/p&gt;&lt;p&gt;Thankfully David Nolen has you covered. &lt;a href="https://github.com/swannodette/mies"&gt;Mies&lt;/a&gt; is a very basic ClojureScript project template so getting up and running is a matter of,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein new mies &amp;lt;project name&amp;gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; &amp;lt;project name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point you are good to go. To compile the ClojureScript you can run,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you open &lt;code&gt;index.html&lt;/code&gt; and view the developer console you should see some predictable output. Alternatively if you run,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The plugin will watch your project sources and recompile everything when changes are made. This is significantly faster that manually compiling every time as compilation is incremental. So instead of 10s of seconds for each compile you'll be getting sub-second compilations.&lt;/p&gt;&lt;h2&gt;Ajax&lt;/h2&gt;&lt;p&gt;When you view HTML files via &lt;code&gt;file://&lt;/code&gt; you won't be able to, at least by default, make ajax calls (due to security concerns such as &lt;a href="https://en.wikipedia.org/wiki/Same-origin_policy"&gt;Same-origin policy&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;To fix this you'll want to serve your &lt;code&gt;index.html&lt;/code&gt; from a web server. You could go with &lt;code&gt;python -m simplehttpserver&lt;/code&gt; as many often do but if you want to keep everything under the same roof (Clojure/Leiningen) then I'd recommend &lt;a href="https://github.com/tailrecursion/lein-simpleton"&gt;&lt;code&gt;lein-simpleton&lt;/code&gt;&lt;/a&gt; - a Leiningen plugin for serving static files from the current directory. If you add &lt;code&gt;lein-simpleton&lt;/code&gt; to the projects &lt;code&gt;project.clj&lt;/code&gt; file,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:plugins&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lein-cljsbuild&lt;/span&gt; &lt;span class="s"&gt;"1.0.2"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-simpleton&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can now run &lt;code&gt;lein simpleton &amp;lt;port&amp;gt;&lt;/code&gt; to start serving static files (your &lt;code&gt;index.html&lt;/code&gt;). Alternatively if you have actual server side code in the same project you can replace &lt;code&gt;lein-simpleton&lt;/code&gt; with &lt;a href="https://github.com/weavejester/lein-ring"&gt;&lt;code&gt;lein-ring&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;Two for One&lt;/h2&gt;&lt;p&gt;So now if you run both&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;lein cljsbuild auto&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lein simpleton &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;You have a dynamic(ish) environment for working and testing your ClojureScript work.&lt;/p&gt;&lt;p&gt;Problem is I don't like having multiple windows open for long running processes and we now have 2. Ruby has a nice answer for this which plays very well with &lt;a href="http://heroku.com"&gt;Heroku&lt;/a&gt; - &lt;a href="https://github.com/ddollar/foreman"&gt;Foreman&lt;/a&gt;. Foreman takes a file (&lt;code&gt;Procfile&lt;/code&gt;) that contains a list of named command line processes and runs them. These processes are supposed to be long running (like &lt;code&gt;simpleton&lt;/code&gt; and &lt;code&gt;cljsbuild auto&lt;/code&gt;) and Foreman merges the output of these files into a single stream that makes development and debugging a bit easier.&lt;/p&gt;&lt;p&gt;Again if you want to keep this sort of thing all under one roof I've thrown together a simple plugin for ingesting a &lt;code&gt;Procfile&lt;/code&gt; and doing what Foreman does - in Leiningen.&lt;/p&gt;&lt;h2&gt;lein-cooper&lt;/h2&gt;&lt;p&gt;&lt;a href="https://github.com/kouphax/lein-cooper"&gt;&lt;code&gt;lein-cooper&lt;/code&gt;&lt;/a&gt; gives you that Foreman feeling. So lets add this as a plugin.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:plugins&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lein-cljsbuild&lt;/span&gt; &lt;span class="s"&gt;"1.0.2"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-simpleton&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-cooper&lt;/span&gt; &lt;span class="s"&gt;"0.0.1"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can create a &lt;code&gt;Procfile&lt;/code&gt; at the root of our project to run our two commands.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;web: lein simpleton
cljs: lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now if we run &lt;code&gt;lein cooper&lt;/code&gt; we will have single call to start up our dynamic(ish) environment for working with ClojureScript. Once you are done just &lt;code&gt;CTRL-C&lt;/code&gt; the terminal and everything will shutdown cleanly.&lt;/p&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;So we now have a very basic project setup that will allow us to tinker with ClojureScript, make Ajax calls, edit code and cleanly automate away all the stopping and restarting and problematic debugging. It's not quite the REPL driven style of a typical Clojure project but it's minimal enough to try a few smaller scale things.&lt;/p&gt;</content></entry><entry><title>lein-cooper - Foreman style process runner for Leiningen</title><updated>Fri May 30 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="http://yobriefca.se/lein-cooper/"></link><id>urn:yobriefca-se:feed:post:lein-cooper - Foreman style process runner for Leiningen</id><content type="html"></content></entry><entry><title>primrose - Experimental promise/future utility functions</title><updated>Wed May 28 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="http://yobriefca.se/primrose/"></link><id>urn:yobriefca-se:feed:post:primrose - Experimental promise/future utility functions</id><content type="html"></content></entry><entry><title>The Weird and Wonderful Characters of Clojure</title><updated>Mon May 19 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/05/19/the-weird-and-wonderful-characters-of-clojure/"></link><id>urn:yobriefca-se:feed:post:The Weird and Wonderful Characters of Clojure</id><content type="html">&lt;style&gt;
  h2 code {background-color: transparent;}
&lt;/style&gt;
&lt;blockquote class="warning" style="text-align:left"&gt;This ancient article has been superseded by a &lt;a href="https://clojure.org/guides/weird_characters"&gt;much better and up to date article on the Clojure website&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;A reference collection of characters used in Clojure that are difficult to "google". Descriptions sourced from various blogs, &lt;a href="http://stackoverflow.com/questions/tagged/clojure"&gt;StackOverflow&lt;/a&gt;, &lt;a href="http://en.wikibooks.org/wiki/Learning_Clojure"&gt;Learning Clojure&lt;/a&gt; and the &lt;a href="http://clojure.org/documentation"&gt;official Clojure docs&lt;/a&gt; - sources attributed where necessary. Type the symbols into the box below to search (or use &lt;code&gt;CTRL-F&lt;/code&gt;). Sections not in any particular order but related items are grouped for ease. If I'm wrong or missing anything worthy of inclusion tweet me &lt;a href="http://twitter.com/kouphax"&gt;@kouphax&lt;/a&gt; or mail me at &lt;a href="mailto:james@yobriefca.se"&gt;james@yobriefca.se&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2&gt;&lt;code&gt;#&lt;/code&gt; - Dispatch macro&lt;/h2&gt;&lt;p&gt;You'll see this macro character beside another e.g. &lt;code&gt;#(&lt;/code&gt; or &lt;code&gt;#"&lt;/code&gt;. This topic will act as a bit preamble before looking at your specific case.&lt;/p&gt;&lt;p&gt;&lt;code&gt;#&lt;/code&gt; is the dispatch macro, a reader macro that tells the Clojure reader (the thing that takes a file of Clojure text and parses it for consumption in the compiler) to go and look at another &lt;strong&gt;read table&lt;/strong&gt; for the definition of the next character - in essence this allows extending default reader behaviour.&lt;/p&gt;&lt;p&gt;Clojure doesn't provide support for creating reader macros but it is possible through &lt;a href="http://briancarper.net/blog/449/"&gt;a bit of hackery&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;If you see &lt;code&gt;#&lt;/code&gt; &lt;strong&gt;at the end&lt;/strong&gt; of a symbol then this is used to automatically generate a new symbol. This is useful inside macros to keep macro specifics from leaking into the userspace. A regular &lt;code&gt;let&lt;/code&gt; will fail in a macro definition&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/m&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;CompilerException&lt;/span&gt; &lt;span class="nv"&gt;java.lang.RuntimeException&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;Can&lt;/span&gt;&lt;span class="ss"&gt;'t&lt;/span&gt; &lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="nv"&gt;qualified&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;user/x&lt;/span&gt;, &lt;span class="nv"&gt;compiling&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;NO_SOURCE_PATH&lt;/span&gt;&lt;span class="ss"&gt;:1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead you need to append &lt;code&gt;#&lt;/code&gt; to the end of the variable name and let Clojure generate a unique symbol for it.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x#&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;x#&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/m&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we expand this macro we can see the &lt;code&gt;gensym&lt;/code&gt;'d name&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;x__681__auto__&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;x__681__auto__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another place you'll see the &lt;code&gt;#&lt;/code&gt; is in &lt;a href="http://clojure.org/reader#The%20Reader--Tagged%20Literals"&gt;tagged literals&lt;/a&gt;. Most commonly you'll see this use in &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt; (extensible data notation - a rich data format that can be used in Clojure) and in ClojureScript (&lt;code&gt;#js&lt;/code&gt;). Search for &lt;code&gt;#inst&lt;/code&gt;, &lt;code&gt;#uuid&lt;/code&gt; or &lt;code&gt;#js&lt;/code&gt; for some more info.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/reader"&gt;Clojure Documentation - Reader&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://briancarper.net/blog/449/"&gt;Clojure Reader Macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojuredocs.org/clojure_core/clojure.core/gensym"&gt;ClojureDocs - gensym&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#{&lt;/code&gt; - Set macro&lt;/h2&gt;&lt;p&gt;See the dispatch (&lt;code&gt;#&lt;/code&gt;) macro for additional details.&lt;/p&gt;&lt;p&gt;&lt;code&gt;#{&lt;/code&gt; defines a set (a collection of unique values) specifically a &lt;code&gt;hash-set&lt;/code&gt;. The following are equivalent,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-set &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Attempting to create a &lt;code&gt;set&lt;/code&gt; using this literal form will throw if there are duplicates. Instead the &lt;code&gt;hash-set&lt;/code&gt; function should be used on a vector&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nv"&gt;IllegalArgumentException&lt;/span&gt; &lt;span class="nv"&gt;Duplicate&lt;/span&gt; &lt;span class="nv"&gt;key&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="nv"&gt;clojure.lang.PersistentHashSet.createWithCheck&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;PersistentHashSet.java&lt;/span&gt;&lt;span class="ss"&gt;:68&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c1"&gt;; convert vector to set, removing duplicates&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/data_structures#Data%20Structures-Sets"&gt;Clojure Documentation: Sets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#_&lt;/code&gt; - Discard macro&lt;/h2&gt;&lt;p&gt;See the dispatch (&lt;code&gt;#&lt;/code&gt;) macro for additional details.&lt;/p&gt;&lt;p&gt;&lt;code&gt;#_&lt;/code&gt; tells the reader to ignore the next form completely.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The docs suggest that "The form following &lt;code&gt;#_&lt;/code&gt; is completely skipped by the reader. (This is a more complete removal than the comment macro which yields nil).". This can prove useful for debugging situations or for multline comments. I've never used it.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/reader"&gt;Clojure Documentation - Reader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#"&lt;/code&gt; - Regular Expression macro&lt;/h2&gt;&lt;p&gt;See the dispatch (&lt;code&gt;#&lt;/code&gt;) macro for additional details.&lt;/p&gt;&lt;p&gt;&lt;code&gt;#"&lt;/code&gt; indicates the start of a regular expression pattern.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;re-matches &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="s"&gt;"^test$"&lt;/span&gt; &lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"test"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This form is compiled at &lt;em&gt;read time&lt;/em&gt; into a &lt;code&gt;java.util.regex.Pattern&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/other_functions#Other%20Useful%20Functions%20and%20Macros-Regex%20Support"&gt;Clojure Documentation: Regex Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#(&lt;/code&gt; - Function macro&lt;/h2&gt;&lt;p&gt;See the dispatch (&lt;code&gt;#&lt;/code&gt;) macro for additional details.&lt;/p&gt;&lt;p&gt;&lt;code&gt;#(&lt;/code&gt; begins the short hand syntax for an inline function definition. The following 2 bits of code are similar,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; anonymous function takin a single argument and printing it&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;; anonymous function takin a single argument and printing it - shorthand&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The macro expands the shorthand syntax into a function definition whose arity (the number of arguments it takes) is defined by how the &lt;code&gt;%&lt;/code&gt; placeholders are declared. See the &lt;code&gt;%&lt;/code&gt; character for discussion around arity.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; argument names shortened for clarity&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#'&lt;/code&gt; - Var macro&lt;/h2&gt;&lt;p&gt;&lt;code&gt;#'&lt;/code&gt; is the var quote. It is the same a the &lt;code&gt;var&lt;/code&gt; method,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;nine&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/nine&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;nine&lt;/span&gt;
&lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;var &lt;/span&gt;&lt;span class="nv"&gt;nine&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/nine&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'nine&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/nine&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When used it will attempt to return the referenced var. This is useful when you want to talk about the reference/declaration instead of the value it represents. See the use of &lt;code&gt;meta&lt;/code&gt; in the metadata (&lt;code&gt;^&lt;/code&gt;) discussion.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/special_forms#var"&gt;Clojure Official Documentation: Special Forms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;#inst&lt;/code&gt;, &lt;code&gt;#uuid&lt;/code&gt; &amp;amp; &lt;code&gt;#js&lt;/code&gt; etc. - tagged literals&lt;/h2&gt;&lt;p&gt;Commonly found in EDN and ClojureScript this use of &lt;code&gt;#&lt;/code&gt; is called the tagged literal. Look at this example,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;java.util.Date.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;inst&lt;/span&gt; &lt;span class="s"&gt;"2014-05-19T19:12:37.925-00:00"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When we create a new date it is represented as a tagged literal, or in this case a tagged string. We can use Clojures &lt;code&gt;read-string&lt;/code&gt; to read this back (or use it directly)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;inst&lt;/span&gt; &lt;span class="s"&gt;"2014-05-19T19:12:37.925-00:00"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;java.util.Date&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-string&lt;/span&gt; &lt;span class="s"&gt;"#inst \"2014-05-19T19:12:37.925-00:00\""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;inst&lt;/span&gt; &lt;span class="s"&gt;"2014-05-19T19:12:37.925-00:00"&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;read-string&lt;/span&gt; &lt;span class="s"&gt;"#inst \"2014-05-19T19:12:37.925-00:00\""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nv"&gt;java.util.Date&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A tagged literal tells the reader how to parse the literal value. Other common uses include &lt;code&gt;#uuid&lt;/code&gt; for generating UUIDs and in the ClojureScript world an extremely common use of tagged literals is &lt;code&gt;#js&lt;/code&gt; which can be used to convert ClojureScript data structures into JavaScript structures directly.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/edn-format/edn#tagged-elements"&gt;EDN Tagged Elements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;%&lt;/code&gt; - Argument placeholder&lt;/h2&gt;&lt;p&gt;&lt;code&gt;%&lt;/code&gt; is not a macro but a placeholder for use in the &lt;code&gt;#(&lt;/code&gt; macro. It represents an argument that will be passed into the function when it is expanded.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; takes a single arg, uses it once&lt;/span&gt;

&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; takes a single arg, uses it twice&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Numbers can be placed directly after the &lt;code&gt;%&lt;/code&gt; to indicate the arguments position. Numbers are also used by the &lt;code&gt;#(&lt;/code&gt; macro to determine the number of arguments to pass in.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%1&lt;/span&gt; &lt;span class="nv"&gt;%2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="nv"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="nv"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; takes 2 args&lt;/span&gt;

&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="nv"&gt;arg2&lt;/span&gt; &lt;span class="nv"&gt;arg3&lt;/span&gt; &lt;span class="nv"&gt;arg4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; takes 4 args doesn't use 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So you don't have to use the arguments but you do need to declare them in the order you'd expect an external caller to pass them in.&lt;/p&gt;&lt;p&gt;&lt;code&gt;%&lt;/code&gt; and &lt;code&gt;%1&lt;/code&gt; can be used interchangably,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;macroexpand &lt;/span&gt;&lt;span class="o"&gt;`#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;%1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; use both % and %1&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fn*&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;clojure.core/println&lt;/span&gt; &lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="nv"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; still only takes 1 argument&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;@&lt;/code&gt; - Deref macro&lt;/h2&gt;&lt;p&gt;&lt;code&gt;@&lt;/code&gt; is the deref macro, it is the shorthand equivalent of the &lt;code&gt;deref&lt;/code&gt; function so these 2 forms are the same,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;atom&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/x&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;deref &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;@&lt;/code&gt; is used to get the current value of a reference. The above example uses &lt;code&gt;@&lt;/code&gt; to get the current value of an &lt;a href="http://clojure.org/atoms"&gt;atom&lt;/a&gt; but &lt;code&gt;@&lt;/code&gt; can be applied to other things such as &lt;code&gt;future&lt;/code&gt;s, &lt;code&gt;delay&lt;/code&gt;s, &lt;code&gt;promise&lt;/code&gt;s etc. to force computation and potentially block.&lt;/p&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;^&lt;/code&gt; - Metadata&lt;/h2&gt;&lt;p&gt;&lt;code&gt;^&lt;/code&gt; is the metadata marker. Metadata is a map of values (with shorthand option) that can be attached to various forms in Clojure. This provides extra information for these forms and can be used for documentation, compilation warnings, typehints and other features.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; meta map with single boolean value&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can access the metadata by the &lt;code&gt;meta&lt;/code&gt; method which should be executed against the declaration itself (rather than the returned value).&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;meta &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ns&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;lt;Namespace&lt;/span&gt; &lt;span class="nv"&gt;user&amp;gt;&lt;/span&gt;, &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt;, &lt;span class="ss"&gt;:column&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;, &lt;span class="ss"&gt;:line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:file&lt;/span&gt; &lt;span class="s"&gt;"NO_SOURCE_PATH"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As we have a single value here we can use a shorthand notation for declaring the metadata &lt;code&gt;^:name&lt;/code&gt; which is useful for flags as the value will be set to true.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;meta &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ns&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;lt;Namespace&lt;/span&gt; &lt;span class="nv"&gt;user&amp;gt;&lt;/span&gt;, &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt;, &lt;span class="ss"&gt;:column&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;, &lt;span class="ss"&gt;:line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:file&lt;/span&gt; &lt;span class="s"&gt;"NO_SOURCE_PATH"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another use of &lt;code&gt;^&lt;/code&gt; is for type hints. These are used to tell the compiler what type the value will be and allow it to perform type specific optimisations thus potentially making resultant code a bit faster.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="nv"&gt;Integer&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;meta &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ns&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;lt;Namespace&lt;/span&gt; &lt;span class="nv"&gt;user&amp;gt;&lt;/span&gt;, &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt;, &lt;span class="ss"&gt;:column&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:file&lt;/span&gt; &lt;span class="s"&gt;"NO_SOURCE_PATH"&lt;/span&gt;, &lt;span class="ss"&gt;:tag&lt;/span&gt; &lt;span class="nv"&gt;java.lang.Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see in that example the &lt;code&gt;:tag&lt;/code&gt; property is set.&lt;/p&gt;&lt;p&gt;You can also stack the shorthand notations,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="nv"&gt;Integer&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="ss"&gt;:private&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;meta &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:ns&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;lt;Namespace&lt;/span&gt; &lt;span class="nv"&gt;user&amp;gt;&lt;/span&gt;, &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt;, &lt;span class="ss"&gt;:column&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:private&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;, &lt;span class="ss"&gt;:debug&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;, &lt;span class="ss"&gt;:line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;, &lt;span class="ss"&gt;:file&lt;/span&gt; &lt;span class="s"&gt;"NO_SOURCE_PATH"&lt;/span&gt;, &lt;span class="ss"&gt;:tag&lt;/span&gt; &lt;span class="nv"&gt;java.lang.Integer&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/metadata"&gt;Clojure Official Documentation: Metadata&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://en.wikibooks.org/wiki/Learning_Clojure/Meta_Data"&gt;Learning Clojure: Meta Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;'&lt;/code&gt; - Quote macro&lt;/h2&gt;&lt;p&gt;Can be used against symbols as part of a dispatch macro (see &lt;code&gt;#'&lt;/code&gt;). Also used to quote forms and prevent their evaluation as with the &lt;code&gt;quote&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; fails as it tries to evaluate 1 as a function&lt;/span&gt;

&lt;span class="nv"&gt;ClassCastException&lt;/span&gt; &lt;span class="nv"&gt;java.lang.Long&lt;/span&gt; &lt;span class="nv"&gt;cannot&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="nb"&gt;cast &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;clojure.lang.IFn&lt;/span&gt;  &lt;span class="nv"&gt;user/eval925&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;NO_SOURCE_FILE&lt;/span&gt;&lt;span class="ss"&gt;:1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; quote&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; using the longer quote method&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/special_forms#quote"&gt;Clojure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;;&lt;/code&gt; - Comment&lt;/h2&gt;&lt;p&gt;&lt;code&gt;;&lt;/code&gt; is a comment. In fact its a comment &lt;strong&gt;macro&lt;/strong&gt; that takes all input from its starting point to the end of the line and ensures the reader ignore it.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; this is a comment&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/x&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="c1"&gt;; this is a comment too&lt;/span&gt;
&lt;span class="nv"&gt;&amp;lt;returns&lt;/span&gt; &lt;span class="nv"&gt;nothing&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;:&lt;/code&gt; - Keyword&lt;/h2&gt;&lt;p&gt;&lt;code&gt;:&lt;/code&gt; is the indicator for a Keyword which is an interned string that provides fast comparison and lower memory overhead.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type&lt;/span&gt; &lt;span class="ss"&gt;:test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;clojure.lang.Keyword&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Alternativley you can use &lt;code&gt;keyword&lt;/code&gt; to create a keyword from a string&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;keyword &lt;/span&gt;&lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="ss"&gt;:test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A neat thing about keywords is they also implement &lt;code&gt;IFn&lt;/code&gt; and can act as functions for extracting values from maps which is very nice.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-map&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:one&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:two&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/my-map&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:one&lt;/span&gt; &lt;span class="nv"&gt;my-map&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; get the value for :one by invoking it as function&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:three&lt;/span&gt; &lt;span class="nv"&gt;my-map&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; it can safely access non-keys&lt;/span&gt;
&lt;span class="nv"&gt;nil&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:three&lt;/span&gt; &lt;span class="nv"&gt;my-map&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; it can return a default if specified&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/data_structures#Data%20Structures-Keywords"&gt;Clojure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;::&lt;/code&gt; - Qualified keyword&lt;/h2&gt;&lt;p&gt;&lt;code&gt;::&lt;/code&gt; is used to fully qualify a keyword with the current namespace.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;:my-keyword&lt;/span&gt;
&lt;span class="ss"&gt;:my-keyword&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="ss"&gt;::my-keyword&lt;/span&gt;
&lt;span class="ss"&gt;:user/my-keyword&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="ss"&gt;::my-keyword&lt;/span&gt; &lt;span class="ss"&gt;:my-keyword&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have found this useful when creating macros. If I want to ensure a macro, that calls another method in the macro namespace, correctly expands to call the method I have used ::my-method to refer to the fully qualified name.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5771168/what-is-the-used-for-in-clojure"&gt;What is the :: used for in clojure?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;/&lt;/code&gt; - Namespace separator&lt;/h2&gt;&lt;p&gt;Can be the division function &lt;code&gt;/&lt;/code&gt; but can also act as a separator in a symbol name to break apart the symbol name and the namespace it resides in &lt;code&gt;my-namepace/utils&lt;/code&gt;. This allows symbols to be fully qualified to prevent collisions or spread.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/reader"&gt;Cloure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;$&lt;/code&gt; - Inner class reference&lt;/h2&gt;&lt;p&gt;Used to reference inner classes and interfaces in Java. Seperates the container class name and the inner class name,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;basex.core&lt;/span&gt; &lt;span class="nv"&gt;BaseXClient$EventNotifier&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;build-notifier&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;notifier-action&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reify&lt;/span&gt; &lt;span class="nv"&gt;BaseXClient$EventNotifier&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;notify&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;notifier-action&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;EventNotifier&lt;/code&gt; is an inner interface of the &lt;code&gt;BaseXClient&lt;/code&gt; class which is an imported Java class.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://blog.jayfields.com/2011/01/clojure-using-java-inner-classes.html"&gt;Clojure: Using Java Inner Classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;-&amp;gt; -&amp;gt;&amp;gt; some-&amp;gt; cond-&amp;gt; as-&amp;gt;&lt;/code&gt; etc. - Threading macros&lt;/h2&gt;&lt;p&gt;These are threading macros. Almost all of them take an initial value and &lt;strong&gt;thread&lt;/strong&gt; this value through a number of forms. Lets imagine (for reasons unknown) we wanted to take a number, find the square root, cast it to an int, then a string then back to an integer again. We could write it like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Integer.&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Math/sqrt&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The threading macro allows us to unravel this deep nesting,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Math/sqrt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nb"&gt;int str &lt;/span&gt;&lt;span class="nv"&gt;Integer.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or if you prefer multiline and consistent brackettering&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;-&amp;gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Math/sqrt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;Integer.&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What the macro does is take the value returned from each expression and push it in as the first argument to the next one.&lt;/p&gt;&lt;p&gt;&lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; is the same but different. Rather than push the last value in as the &lt;strong&gt;first&lt;/strong&gt; argument it passes it in as the &lt;strong&gt;last&lt;/strong&gt; argument.&lt;/p&gt;&lt;p&gt;The "etc." in the title refers to the fact there are a whole host of threading macros that perform variations on the same theme (&lt;code&gt;cond-&amp;gt;&lt;/code&gt;, &lt;code&gt;some-&amp;gt;&lt;/code&gt;, &lt;code&gt;as-&amp;gt;&lt;/code&gt; and their &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; equivalents). There is also an entire library, &lt;a href="https://github.com/rplevy/swiss-arrows"&gt;swiss-arrows&lt;/a&gt;, dedicated to the threading macros.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/"&gt;Understanding the Clojure -&amp;gt; macro&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/clojure/clojure/blob/67571d1844e7b9a0cab6089245d7e5cde208c67e/changes.md"&gt;Clojure Changelog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;~&lt;/code&gt; - Unquote macro&lt;/h2&gt;&lt;p&gt;See &lt;code&gt;`&lt;/code&gt; (syntax quote) for additional information.&lt;/p&gt;&lt;p&gt;&lt;code&gt;~&lt;/code&gt; is unquote. That is within as syntax quoted (&lt;code&gt;`&lt;/code&gt;) block &lt;code&gt;~&lt;/code&gt; will &lt;strong&gt;unquote&lt;/strong&gt; the associated symbol i.e. resolve it in the current context.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; create a named ref representing the number 5&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="c1"&gt;; five will yeild its internal value&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="c1"&gt;; syntax quoting five will fully resolve the SYMBOL&lt;/span&gt;
&lt;span class="nv"&gt;user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`~&lt;/span&gt;&lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="c1"&gt;; within a syntax quoted block ~ wil resolve the value in the current context&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This forms the meat and potatoes of creating macros which are, to be highly reductionist, functions that return blocks of syntax with parts evaluated in varying contexts.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.braveclojure.com/writing-macros/"&gt;Clojure for the Brave and True - Writing Macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://aphyr.com/posts/305-clojure-from-the-ground-up-macros"&gt;Clojure from the ground up: macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/macros"&gt;Clojure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;~@&lt;/code&gt; - Unquote splicing macro&lt;/h2&gt;&lt;p&gt;See &lt;code&gt;`&lt;/code&gt; (syntax quote) and &lt;code&gt;~&lt;/code&gt; (unquote) for additional information.&lt;/p&gt;&lt;p&gt;&lt;code&gt;~@&lt;/code&gt; is unquote-splicing. Where unquote (&lt;code&gt;~&lt;/code&gt;) deals with single values (or treats its attached item as a single item) &lt;code&gt;~@&lt;/code&gt; works on lists and expands them out into multiple statements. Think JavaScripts &lt;code&gt;.apply&lt;/code&gt; method that takes an array and expands it out as arguments to the applied function.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;three-and-four&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/three-and-four&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;three-and-four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; treates as a single statement produces a nested list&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;~@&lt;/span&gt;&lt;span class="nv"&gt;three-and-four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; expand out as seperate statements&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again this gives us a lot of power in macros.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.braveclojure.com/writing-macros/"&gt;Clojure for the Brave and True - Writing Macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://aphyr.com/posts/305-clojure-from-the-ground-up-macros"&gt;Clojure from the ground up: macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/macros"&gt;Clojure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;`&lt;/code&gt; - Syntax quote&lt;/h2&gt;&lt;p&gt;See &lt;code&gt;~@&lt;/code&gt; (unquote splicing) and &lt;code&gt;~&lt;/code&gt; (unquote) for additional information.&lt;/p&gt;&lt;p&gt;&lt;code&gt;`&lt;/code&gt; is the syntax quote. When used on a symbol it resolves the symbol in the current context,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/five&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;five&lt;/span&gt;
&lt;span class="nv"&gt;user/five&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When used with lists (remember every thing in Clojure is data) it forms a &lt;strong&gt;template&lt;/strong&gt; for the data structure and won't immediately resolve it.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;ClassCastException&lt;/span&gt; &lt;span class="nv"&gt;java.lang.Long&lt;/span&gt; &lt;span class="nv"&gt;cannot&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="nb"&gt;cast &lt;/span&gt;&lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;clojure.lang.IFn&lt;/span&gt;  &lt;span class="nv"&gt;user/eval832&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;NO_SOURCE_FILE&lt;/span&gt;&lt;span class="ss"&gt;:1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You'll see this most often in the context of macros. We can write one now,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defmacro &lt;/span&gt;&lt;span class="nv"&gt;debug&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;   &lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;val#&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nv"&gt;body&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"DEBUG: "&lt;/span&gt; &lt;span class="nv"&gt;val#&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;_=&amp;gt;&lt;/span&gt;      &lt;span class="nv"&gt;val#&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/debug&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;debug&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nv"&gt;DEBUG&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;Code updated based on recommendations from Leif Foged&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;The macro takes a single statement wraps it in a &lt;strong&gt;quoted&lt;/strong&gt; &lt;code&gt;let&lt;/code&gt; block, evaluates and prints the result and then evaluates the body. In effect this &lt;code&gt;defmacro&lt;/code&gt; call returns a quoted data structure representing the program we are writing with it. The &lt;code&gt;`&lt;/code&gt; allows this to happen.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://www.braveclojure.com/writing-macros/"&gt;Clojure for the Brave and True - Writing Macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://aphyr.com/posts/305-clojure-from-the-ground-up-macros"&gt;Clojure from the ground up: macros&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojure.org/macros"&gt;Clojure Official Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;*var-name*&lt;/code&gt; - Earmuffs&lt;/h2&gt;&lt;p&gt;Earmuffs (a pair of asterisk bookending var names) is a &lt;strong&gt;naming convention&lt;/strong&gt; in many LISPs used to denote &lt;strong&gt;special vars&lt;/strong&gt;. Most commonly in Clojure this seems to be used to denote &lt;strong&gt;dynamic&lt;/strong&gt; vars i.e. ones that can change depending on where you are in the program. The earmuffs act as a warning that "here be dragons" and to never assume the state of the var. Remember this is a &lt;strong&gt;convention&lt;/strong&gt; not a &lt;strong&gt;rule&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;Core Clojure examples are &lt;code&gt;*out*&lt;/code&gt; and &lt;code&gt;*in*&lt;/code&gt; which represent the standard in and out Writers for Clojure.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1986961/how-is-the-var-name-naming-convention-used-in-clojure"&gt;How is the &lt;em&gt;var-name&lt;/em&gt; naming-convention used in clojure?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/*out*"&gt;Clojure API Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;&amp;gt;!!&lt;/code&gt;, &lt;code&gt;&amp;lt;!!&lt;/code&gt;, &lt;code&gt;&amp;gt;!&lt;/code&gt; &amp;amp; &lt;code&gt;&amp;lt;!&lt;/code&gt; - core.async channel macros&lt;/h2&gt;&lt;p&gt;These symbols are channel operations in &lt;code&gt;core.async&lt;/code&gt; - a Clojure/ClojureScript library for channel based asynchronous programming (specifically &lt;a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes"&gt;CSP - Communicating Sequential Processes&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;If you imagine, for the sake of argument, a channel is a bit like a queue that things can put stuff on and take stuff off then these symbols support that simple API.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;&amp;gt;!!&lt;/code&gt; &amp;amp; &lt;code&gt;&amp;lt;!!&lt;/code&gt; are &lt;strong&gt;blocking&lt;/strong&gt; &lt;strong&gt;put&lt;/strong&gt; and &lt;strong&gt;take&lt;/strong&gt; respectively&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;&amp;gt;!&lt;/code&gt; &amp;amp; &lt;code&gt;&amp;lt;!&lt;/code&gt; are, simply, &lt;strong&gt;put&lt;/strong&gt; and &lt;strong&gt;take&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The difference being the blocking versions operate outside &lt;code&gt;go&lt;/code&gt; blocks and block the thread they operate on.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-channel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; create a channel&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!!&lt;/span&gt; &lt;span class="nv"&gt;my-channel&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;; put stuff on the channel&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!!&lt;/span&gt; &lt;span class="nv"&gt;my-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; take stuff off the channel&lt;/span&gt;
&lt;span class="nv"&gt;hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The non-blocking versions need to be executed within a &lt;code&gt;go&lt;/code&gt; block otherwise they'll throw an exception&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/c&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="s"&gt;"nope"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;AssertionError&lt;/span&gt; &lt;span class="nv"&gt;Assert&lt;/span&gt; &lt;span class="nv"&gt;failed&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;used&lt;/span&gt; &lt;span class="nb"&gt;not &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="nv"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;block&lt;/span&gt;
&lt;span class="nv"&gt;nil&lt;/span&gt;  &lt;span class="nv"&gt;clojure.core.async/&amp;gt;!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;async.clj&lt;/span&gt;&lt;span class="ss"&gt;:123&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While the difference between these is well outside the scope of this article fundamentally the &lt;code&gt;go&lt;/code&gt; blocks operate and manage their own resources pausing &lt;strong&gt;execution&lt;/strong&gt; of code without blocking threads. This makes asynchronously executed code appear to be synchronous and removing the pain of managing asynchronous code from the code base.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj"&gt;core.async Code Walkthrough&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/clojure/core.async/wiki"&gt;core.async Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;&amp;lt;symbol&amp;gt;?&lt;/code&gt; - Predicate Marker&lt;/h2&gt;&lt;p&gt;Putting &lt;code&gt;?&lt;/code&gt; at the end of a symbol is a &lt;strong&gt;naming convention&lt;/strong&gt; common across many languages that support special characters in their symbol names It is used to indicate the thing is a predicate i.e. that it &lt;strong&gt;poses a question&lt;/strong&gt;. For example imagine using an API that dealt with buffer manipulation&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffers/create-buffer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffers/empty&lt;/span&gt; &lt;span class="nv"&gt;my-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At a glance how would you know if the method &lt;code&gt;empty&lt;/code&gt; in this case,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Returned true if the passed in buffer was empty, or,&lt;/li&gt;
  &lt;li&gt;Cleared the buffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;While the author could have renamed &lt;code&gt;empty&lt;/code&gt; to &lt;code&gt;is-empty&lt;/code&gt; the richness of symbol naming in Clojure allows us to express intent more symbolically.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffers/create-buffer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffers/empty?&lt;/span&gt; &lt;span class="nv"&gt;my-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is simply a recommended &lt;strong&gt;convention&lt;/strong&gt; not a &lt;strong&gt;requirement&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/bbatsov/clojure-style-guide#naming"&gt;Clojure Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;&amp;lt;symbol&amp;gt;!&lt;/code&gt; - Unsafe Operations&lt;/h2&gt;&lt;p&gt;The Clojure style guide has this to say&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;The names of functions/macros that are not safe in STM transactions should end with an exclamation mark (e.g. &lt;code&gt;reset!&lt;/code&gt;).&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;You'll most commonly see this appended to function names whose purpose is to mutate state e.g connecting to a data store, updating an atom or closing a file stream.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-stateful-thing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;atom&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="ss"&gt;'user/my-stateful-thing&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nv"&gt;my-stateful-thing&lt;/span&gt; &lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;user=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;my-stateful-thing&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is simply a recommended &lt;strong&gt;convention&lt;/strong&gt; not a &lt;strong&gt;requirement&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/bbatsov/clojure-style-guide#naming"&gt;Clojure Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;&lt;h2&gt;&lt;code&gt;_&lt;/code&gt; - Irrelevant var&lt;/h2&gt;&lt;p&gt;When you see this used as function arguments or similar it is a common naming convention for vars or arguments you are not interested in using. That is you don't intend to use them so you aren't really interested in thinking of a useful name for them.&lt;/p&gt;&lt;p&gt;This is an example using the &lt;code&gt;add-watch&lt;/code&gt; function that can be used to add callback style behavior when atoms change value. Imagine, given an atom, we want to print the new value everytime it changes,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;atom&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-watch&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="nv"&gt;_&lt;/span&gt; &lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reset!&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; prints 6&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reset!&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; prints 9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;add-watch&lt;/code&gt; takes 4 arguments but in our case we only really care about the last argument - the new value of the atom. I don't really want to spend time thinking of names for these arguments I'll never use, nor do I want to generate a long line of text unnecessarily (of course I could have used the shorthand &lt;code&gt;#(println %4)&lt;/code&gt; but that defeats the purpose of this example).&lt;/p&gt;
&lt;hr /&gt;
&lt;script&gt;
(function(){
  var script = document.createElement('script');
  script.src = "https://code.jquery.com/jquery-1.11.3.min.js"
  script.onload = function(){
    // wraps h3 in block
    jQuery("h2").each(function(){
      jQuery(this).nextUntil("h2")
           .andSelf()
           .wrapAll("&lt;div class='block'/&gt;")
    })

    jQuery('blockquote:first').after(jQuery("&lt;input type='search' id='filter' placeholder='Search symbols..'/&gt;").css({
      "font-size"      : "1.5em",
      "width"          : "100%",
      "border"         : "1px solid #e0e0e0",
      "text-indent"    : "0.5em",
      "color"          : "#999",
      "font-family"    : "Open Sans",
      "padding-top"    : "0.2em",
      "padding-bottom" : "0.2em"
    }))

    var all = jQuery('h2').parents(".block")

    var filter = function(e){
      if(this.value === "") {
        all.show();
      } else {
        all.hide()
        jQuery('h2 code:contains(' + this.value + ')').parents(".block").show();
      }
    };

    jQuery('#filter').on("keyup", filter).on("click", filter);
  }
  document.getElementsByTagName('head')[0].appendChild(script);
})();
&lt;/script&gt;
&lt;blockquote&gt;&lt;p&gt;Many thanks to everyone who has contributed ideas and [the copious amounts of] spelling corrections (crikey I'm bad at speelingz - so thanks Michael R. Mayne, lobsang_ludd). I've tried to call out people who have specifically asked for things. Sorry if I've missed you.&lt;/p&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Clojure Cookbook</title><updated>Thu May 15 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/05/15/clojure-cookbook/"></link><id>urn:yobriefca-se:feed:post:Clojure Cookbook</id><content type="html">&lt;p&gt;&lt;img src="/images/blog/clojure_cookbook.png" alt="Clojure Cookbook" _="_" /&gt;&lt;/p&gt;&lt;p&gt;Broad. If I had to describe the &lt;a href="http://clojure-cookbook.com/"&gt;Clojure Cookbook&lt;/a&gt; in a single word &lt;strong&gt;broad&lt;/strong&gt; would be it. If you're looking for in-depth explanations of all the minutiae and edge cases of a particular topic in Clojure this book is probably not going to fit the bill. If, on the other hand, you're spelunking through the Clojure landscape building apps and generally tinkering with everything you get your hands on then this book is the perfect companion.&lt;/p&gt;&lt;h2&gt;What is it?&lt;/h2&gt;&lt;p&gt;The &lt;a href="http://clojure-cookbook.com/"&gt;Clojure Cookbook&lt;/a&gt;, as the name suggests, is a collection of recipes (short-ish articles) for achieving various things with Clojure. Recipes cover a broad range of topics. You'll encounter string manipulation, writing web apps, Datomic, testing with Midje, Cascalog and a bunch of other things. On quick calculation there are about 169 recipes in the book from about 60 contributors, all reviewed and curated by the books authors.&lt;/p&gt;&lt;h2&gt;Who is it for?&lt;/h2&gt;&lt;p&gt;Good question. A broad book is going to have broad appeal. If you're starting on your Clojure journey you will initially find usefulness in the more low level recipes in the book and eventually graduate to the more general higher level recipes such as writing web apps and accessing databases. But if you've been working with Clojure for some time there is always going to be some aspect or task you've not had to deal with yet and again many recipes in this book could prove useful. At the very least they could act as refreshers for the tasks you only need to approach once in a while.&lt;/p&gt;&lt;p&gt;Another way to consider using this book is as inspiration. If you're wanting to take your Clojure experience to the next level and venture into new areas you could use this book as a sort of guide. This is where I see the charm in this type of book rather than the function. In my downtime I like flicking open the contents and picking a recipe at random and having a play with whatever technique or technology it's focused on.&lt;/p&gt;&lt;p&gt;That said if you like to get down to the nuts and bolts of a topic and really dig into it you're going to need another way to do that. The recipes in this book usually offer some insight into the rationale behind them (they "why?" if you will) but given their terse nature you could be left with outstanding questions. Also, the level of detail in each recipe varies e.g. you can expect more discussion around an article covering, say, string manipulation than you will about broader topics like distributed computing. That said you are never left wondering why you'd actually do the thing you are reading about - it's either obvious or discussed.&lt;/p&gt;&lt;h2&gt;Worth it?&lt;/h2&gt;&lt;p&gt;Yeah. Listen - you don't need to buy this book. Its available for free &lt;a href="https://github.com/clojure-cookbook/clojure-cookbook"&gt;online&lt;/a&gt; and a quick Googling could often lead you to articles on the same topics but lets think about this a little differently. Books like this are the result of community collaboration, of people coming together and producing a body of work that deserves a place on your bookshelf. So, without getting to idealistic, not only are you enriching yourself but you are celebrating community and I value that.&lt;/p&gt;&lt;p&gt;As a body of work - online or off - whether you are diving into Clojure for the first time or a seasoned veteran about to venture into a new area of the ecosystem there is something in this book you can get value from.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;I was fortunate enough to receive a complimentary copy of the Clojure Cookbook but I was in no way contracted to write a review. I do so simply because it's the least I could do to promote a book I find useful.&lt;/p&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Managing Environment Variables in Clojure</title><updated>Tue Apr 29 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/04/29/managing-environment-variables-in-clojure/"></link><id>urn:yobriefca-se:feed:post:Managing Environment Variables in Clojure</id><content type="html">&lt;blockquote&gt;&lt;p&gt;If you've never read the &lt;a href="http://12factor.net/"&gt;Twelve Factor App&lt;/a&gt; methodology I strongly recommend you do, it's a great guide born from real life experience of building many, many web applications.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;One of the rules in the &lt;a href="http://12factor.net/"&gt;Twelve Factor App&lt;/a&gt; methodology is that you &lt;a href="http://12factor.net/config"&gt;"Store config in the environment"&lt;/a&gt; or, more specifically, store config that is likely to change &lt;strong&gt;across environments&lt;/strong&gt; in the environment. It makes sense as it ties the target environment and its necessary configuration together instead of having to juggle &lt;code&gt;if ENV=test|dev&lt;/code&gt; style flags around your code base or swap out different config files per build.&lt;/p&gt;&lt;p&gt;One other positive side effect of this approach is that secure configuration doesn't accidentally get checked into source. Every one needs database credentials or client secrets but no-one want to share them with the world.&lt;/p&gt;&lt;p&gt;Supporting this approach in Clojure is fairly simple and there are a few ways to do it.&lt;/p&gt;&lt;h2&gt;System/getenv&lt;/h2&gt;&lt;p&gt;Clojure sits on the JVM and the JVM has the &lt;code&gt;System&lt;/code&gt; namespace which provides utilities and classes for accessing the running systems features. &lt;code&gt;System.getenv&lt;/code&gt; and &lt;code&gt;System.getenv(String)&lt;/code&gt; give us access to environment variables from Clojure.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;System/getenv&lt;/span&gt; &lt;span class="s"&gt;"DATABASE_URL"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;=&amp;gt; http://user:pass@dburl/mydb&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also provide a fallback for environment variables that don't exist&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;System/getenv&lt;/span&gt; &lt;span class="s"&gt;"NOEXIST_DATABASE_URL"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="s"&gt;"http://localhost/mydb"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;=&amp;gt; http://localhost/mydb&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case &lt;code&gt;NOEXIST_DATABASE_URL&lt;/code&gt; isn't set as an environment variable so we fallback to our hardcoded version. &lt;/p&gt;&lt;p&gt;This isn't uncommon and often its done to support development environments. For example &lt;a href="http://heroku.com"&gt;Heroku&lt;/a&gt; (where the original 12 factor app methodology arose) add environment variables for any addons you may activate such as &lt;code&gt;DATABASE_URL&lt;/code&gt; for the Postgres DB addon. So rather than write different handlers per environment many people would either.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Use the fallback URL to represent their development environment&lt;/li&gt;
  &lt;li&gt;Add the environment variable to their shell&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Both of the approaches have problems. Using a fallback URL can lead to problems where an environment isn't correctly configured and starts using the wrong database. If it can write to it there will be trouble, if it can't you'll be scratching your head wondering whats going wrong for longer then necessary. Setting a project specific environment variable in your shell can lead to pain when things get overwritten across projects and pollution if you're setting it in an automated fashion (&lt;code&gt;.bashrc&lt;/code&gt;) or you'll simply forget to set it per use when doing it manually.&lt;/p&gt;&lt;h2&gt;weavejester/environ&lt;/h2&gt;&lt;p&gt;A neater solution is available in the form of &lt;a href="https://github.com/weavejester/environ"&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt; - a simple library for managing environment variables. The clever thing &lt;a href="https://github.com/weavejester/environ"&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt; does is merge environment variables from multiple sources into a single map.&lt;/p&gt;&lt;p&gt;So by adding it to our &lt;code&gt;project.clj&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;environ&lt;/span&gt; &lt;span class="s"&gt;"0.5.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can import and use it where we need,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;environ.core&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;env&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;env&lt;/span&gt; &lt;span class="ss"&gt;:database-url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;;=&amp;gt; http://localhost/mydb&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So how are the environment variables sourced? Well environ looks in a number of areas in order,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A &lt;code&gt;.lein-env&lt;/code&gt; file in the project directory&lt;/li&gt;
  &lt;li&gt;Environment variables&lt;/li&gt;
  &lt;li&gt;Java system properties&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;It also keywordises the variable names as you can see from the example above.&lt;/p&gt;&lt;p&gt;Great, so why is this more useful? The big benefit I've discovered is the &lt;code&gt;.lein-env&lt;/code&gt; file in the root of my project. This file holds a map of environment values that can be useful during development. There are 2 ways to create this file.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The RIGHT way as set out by the creator of the project, and,&lt;/li&gt;
  &lt;li&gt;The WRONG way as in how I use it&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;environ&lt;/code&gt; also has a plugin available &lt;code&gt;lein-environ&lt;/code&gt; which sucks profile specific settings from &lt;code&gt;~/.lein/profiles.clj&lt;/code&gt; and/or a project specific &lt;code&gt;profiles.clj&lt;/code&gt; (which should not be checked into source) and creates the &lt;code&gt;.lein-env&lt;/code&gt; file when Leiningen does its thing (effectively making &lt;code&gt;.lein-env&lt;/code&gt; a transient file). A &lt;code&gt;.lein-env&lt;/code&gt; file looks a little something like this.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:env&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:database-url&lt;/span&gt; &lt;span class="s"&gt;"http://localhost/mydb"&lt;/span&gt; 
         &lt;span class="ss"&gt;:client-token&lt;/span&gt; &lt;span class="s"&gt;"QWERTY12345"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Caveat:&lt;/strong&gt; Now you &lt;strong&gt;can&lt;/strong&gt; create this manually (this is what I have done for a small project I'm working on) but it's not officially recommended for a few reasons. Firstly the minute you add the &lt;code&gt;lein-environ&lt;/code&gt; plugin to the project your important setting will get wiped out and secondly you lose out on the ability to vary setting across profiles as well that you'd get from &lt;code&gt;profiles.clj&lt;/code&gt;. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Big thanks to &lt;a href="https://twitter.com/weavejester"&gt;@weavejester&lt;/a&gt; the creator of &lt;code&gt;environ&lt;/code&gt; for the tip off about my dubious use of &lt;code&gt;.lein-env&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;So back to &lt;code&gt;.lein-env&lt;/code&gt; - You end up with the &lt;code&gt;.lein-env&lt;/code&gt; file on your machine with development (or profile) specific values and you forget about fallbacks and setting environment variables and the potential conflicts with other projects. Then on your production and test systems you can source values from actual environment variables without having to change your strategy or use &lt;code&gt;(if (= "test" (:env config)))&lt;/code&gt; style checks.&lt;/p&gt;&lt;p&gt;Its worth noting that &lt;code&gt;.lein-env&lt;/code&gt; is already added as a match in the default &lt;code&gt;.gitignore&lt;/code&gt; from &lt;code&gt;lein new ...&lt;/code&gt; so wont be checked into &lt;code&gt;git&lt;/code&gt; - &lt;strong&gt;BUUUUUUT...&lt;/strong&gt; if you do manage to check in and push your &lt;code&gt;.lein-env&lt;/code&gt; file (or any project specific &lt;code&gt;profiles.clj&lt;/code&gt; file) and it does happen to contain secure tokens and passwords (hashed or otherwise) you must assume those values are already compromised even if you manage to purge them from history.&lt;/p&gt;</content></entry><entry><title>Experience Report: Migrating from Middleman to Stasis</title><updated>Tue Apr 01 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/04/01/experience-report-migrating-from-middleman-to-stasis/"></link><id>urn:yobriefca-se:feed:post:Experience Report: Migrating from Middleman to Stasis</id><content type="html">&lt;p&gt;I recently migrated my statically generated site (yep this site) from a Ruby/&lt;a href="http://middlemanapp.com"&gt;Middleman&lt;/a&gt; solution to a Clojure/&lt;a href="https://github.com/magnars/stasis"&gt;Stasis&lt;/a&gt; based solution. This post is a kind of experience report on the migration process. It isn't a guide for using &lt;a href="https://github.com/magnars/stasis"&gt;Stasis&lt;/a&gt; and if that is something you're looking for I can't recommend Christian Johansens "&lt;a href="http://cjohansen.no/building-static-sites-in-clojure-with-stasis"&gt;Building static sites with Clojure&lt;/a&gt;" post enough.&lt;/p&gt;&lt;h2&gt;Background&lt;/h2&gt;&lt;p&gt;My site has transitioned through various platforms - from WordPress to Posterous, Jekyll and Middleman. Its also went through a few types - Internal corporate blog, public blog and finally a site that represents my role as a contractor.&lt;/p&gt;&lt;p&gt;I never really enjoyed WordPress or Posterous because there was a distinct lack of control and way too many features and points of failure and while Jekyll gave me flexibility its pattern for extension was rather undocumented and ambiguious. Middleman offered me the flexibility with a very simple programming model.&lt;/p&gt;&lt;p&gt;The next migration, the one I'm covering now, came about because the site had accrued a lot of content debt over the years and I needed to tidy it up. Problems such as&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;duplicated and redundant YAML frontmatter settings and logic,&lt;/li&gt;
  &lt;li&gt;a lot of different file types&lt;/li&gt;
  &lt;li&gt;the migrated Posterous stuff was locked up in prerendered HTML&lt;/li&gt;
  &lt;li&gt;many of the older posts use embedded gists and I wasn't happy with that&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Decision to Migrate&lt;/h2&gt;&lt;p&gt;So why move from Ruby to Clojure, Middleman to Stasis? Truth be told it was initially a learning experience. I was knee deep in using Clojure and decided the project was substantial enough to help further my education. I had started with refactoring the existing Ruby codebase but the content tidy up effort was proving awkward in Ruby. Once I started the work in Clojure it was clear I was able to better express my intent.&lt;/p&gt;&lt;h2&gt;Observations&lt;/h2&gt;&lt;p&gt;The next few sections are observations I've made during the migration.&lt;/p&gt;&lt;h3&gt;Stasis gives you less (and that's OK)&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;Statis just offers a few functions that are useful when creating static web sites.&lt;/p&gt;&lt;p&gt;No more. There are no batteries included.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Thats directly from the Stasis &lt;a href="https://github.com/magnars/stasis/blob/master/README.md"&gt;README&lt;/a&gt; and as you can guess it's spot on. Fundamentally speaking Stasis gives you two entry points&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A ring handler for serving content&lt;/li&gt;
  &lt;li&gt;An &lt;code&gt;export-pages&lt;/code&gt; function for saving content to disk&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Both of these expect a map of &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; and thats it. You could serve an simple hello world style site like this.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;stasis.core/export-pages&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;"/index.html"&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Hello World&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
                          &lt;span class="s"&gt;"build"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running that would result in and &lt;code&gt;index.html&lt;/code&gt; file in the &lt;code&gt;/build&lt;/code&gt; folder of your project with the contents above.&lt;/p&gt;&lt;p&gt;To complement this stasis also gives you a method to &lt;code&gt;slurp&lt;/code&gt; a directory, read its contents and generate one of these content maps. This is an excellent starting point for transforming file based content.&lt;/p&gt;&lt;p&gt;In my site I slurp a directory of metadata enriched markdown files (YAML frontmatter) and thread them through a bunch of transformation functions. The heart of my content processing is a simple little function&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;entries&lt;/span&gt;
  &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;entries&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;slurp-content&lt;/span&gt; &lt;span class="s"&gt;"resources/content/entries"&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;entries&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;filter &lt;/span&gt;&lt;span class="ss"&gt;:published&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;map &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;assoc &lt;/span&gt;&lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="ss"&gt;:uri&lt;/span&gt;
                      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;keyword &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:type&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                        &lt;span class="ss"&gt;:article&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;article-uri&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="ss"&gt;:screencast&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;screencast-uri&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="ss"&gt;:talk&lt;/span&gt;       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:url&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                        &lt;span class="ss"&gt;:project&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:url&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort-by &lt;/span&gt;&lt;span class="ss"&gt;:date&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;slurp-content&lt;/code&gt; in this function extracts the file contents and converts it to a map based on the YAML frontmatter and the content body&lt;/p&gt;&lt;p&gt;At the end each bit of content (article, screencast, talk entry etc.) is a map that can be passed around to generate category pages, RSS feeds, HTML pages. Content as data so to speak. So in future if I want to provide a JSONified version of all talk metadata I can just add another function that merges my new paths into the site map that Stasis uses.&lt;/p&gt;&lt;p&gt;This sort of work was mostly handled by Middleman internally and transformations configured by providing different file extensions to the content (which could be stacked like &lt;code&gt;.html.erb.md&lt;/code&gt;). This meant that behaviour was controlled by manipulating content rather than it being treated as data. In Stasis this means there is a bit more code involved but the end result is perfectly acceptable.&lt;/p&gt;&lt;p&gt;There is a simplicity in Stasis I could never achieve with Middleman.&lt;/p&gt;&lt;h3&gt;Expressiveness of Clojure&lt;/h3&gt;&lt;p&gt;When it came to tidying up the content I found the use of an interactive REPL and a few simple libraries meant I was able to achieve things quickly and easily. When working with files combining the REPL with Git gave me a transactional approach to messing with files without fear. I've saved most of my efforts in the fom of a &lt;a href="https://gist.github.com/kouphax/9854290"&gt;gist&lt;/a&gt; for this work.&lt;/p&gt;&lt;p&gt;One of the biggest challenges I came up against was taking the old articles that contained embedded gists and replacing these with syntax highlighted code blocks. This involved&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Scraping the &lt;code&gt;script&lt;/code&gt; tags that linked to embedded gists from the articles&lt;/li&gt;
  &lt;li&gt;Using the Github API to load the content and file type of each Gist (some had multiple files)&lt;/li&gt;
  &lt;li&gt;Run the content through the pygments based syntax highlighter to produce a code block&lt;/li&gt;
  &lt;li&gt;Swap the &lt;code&gt;script&lt;/code&gt; and potential &lt;code&gt;noscript&lt;/code&gt; block from the offending files&lt;/li&gt;
  &lt;li&gt;Write the new content out.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;It sounds easy on paper (and maybe for you it is) but previous attempts in Ruby had driven me to give up. With Clojure and &lt;a href="https://github.com/cgrand/enlive"&gt;Enlive&lt;/a&gt; this work was easier to express and achieve. Of course it wasn't without problems. I found &lt;a href="https://github.com/cgrand/enlive"&gt;Enlive&lt;/a&gt; confusing at times but the interactive nature of the REPL meant I could break the problem down and isolate pain points.&lt;/p&gt;&lt;p&gt;Clojures REPL is more powerful than &lt;code&gt;irb&lt;/code&gt; and this allowed me to babystep my problems. Clojures syntax, simplicity and powerful standard lib allowed me to express my intent more clearly, with less code and fewer problems. The two together gave me an environment that allowed me to get to where I wanted with fewer frustrations.&lt;/p&gt;&lt;h3&gt;Generation Time&lt;/h3&gt;&lt;p&gt;I build my site with an alias I set up &lt;code&gt;lein build-site&lt;/code&gt;. Previously I used &lt;code&gt;bundle exec middleman build&lt;/code&gt;. At first I noticed that the time to generate the static site in Clojure felt a lot longer. In fact the generation process itself is probably a bit slower. But, there is always a &lt;em&gt;but&lt;/em&gt;, overall a fresh build and deploy (thanks to &lt;a href="https://travis-ci.org/kouphax/yobriefca.se"&gt;Travis&lt;/a&gt;) actually takes a tiny bit less (a few seconds difference, nothing to write home about).&lt;/p&gt;&lt;p&gt;It seems a lot of the build time in Ruby comes from the resolution of dependencies of which Middleman has a lot more than Stasis. Note: This analysis is by no means in-depth of course and ultimatley it still only takes about 3 minutes from commiting a chance to seeing it live (depending on the speed of Travis picking it up).&lt;/p&gt;&lt;h2&gt;Credits&lt;/h2&gt;&lt;p&gt;I've previously mentioned Christian Johansens "&lt;a href="http://cjohansen.no/building-static-sites-in-clojure-with-stasis"&gt;Building static sites with Clojure&lt;/a&gt;" post and I'd like to acknowledge that it was the post that finally made me decide to migrate. His post was invaluable during the inital migration (especially around the syntax highlighting).&lt;/p&gt;&lt;p&gt;While the post kicked of the decision to migrate the following list of technolgies made that transition possible.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/magnars/stasis"&gt;Stasis&lt;/a&gt; - provides the core of the site generation&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/magnars/optimus"&gt;Optimus&lt;/a&gt; - Static asset optimisation (bundling, minification etc.)&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/cgrand/enlive"&gt;Enlive&lt;/a&gt; - DOM manipulation library that was an essential part of unembedding the gists and replaceing code blocks with syntax highlighted blocks.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/Raynes/cegdown"&gt;cegdown&lt;/a&gt; - Markdown processing library. Essentially a Clojure wrapper for &lt;a href="https://github.com/sirthias/pegdown"&gt;Pegdown&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/lancepantz/clj-yaml"&gt;clj-yaml&lt;/a&gt; - Encoding and decoding of YAML frontmatter&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/Raynes/fs"&gt;fs&lt;/a&gt; - A bunch of file system utilities. Used a lot when renaming and replating content files.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/pelle/slugger"&gt;slugger&lt;/a&gt; - Genreates HTML friendly slugs for articles. This is a port of the stringex Ruby library used in Middleman which was essential to avoid breaking original urls&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/bfontaine/clygments"&gt;clygments&lt;/a&gt; - A Clojure wrapper around then Pygments syntax highlighting library.&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>flic - Simple feature toggles</title><updated>Thu Mar 13 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="http://yobriefca.se/flic/"></link><id>urn:yobriefca-se:feed:post:flic - Simple feature toggles</id><content type="html"></content></entry><entry><title>Building Command Line Apps with Clojure</title><updated>Sun Mar 02 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/03/02/building-command-line-apps-with-clojure/"></link><id>urn:yobriefca-se:feed:post:Building Command Line Apps with Clojure</id><content type="html">&lt;p&gt;I recently read an article by &lt;a href="http://rkn.io"&gt;Ryan Neufeld&lt;/a&gt; around &lt;a href="http://www.rkn.io/2014/02/27/clojure-cookbook-command-line-args/"&gt;parsing command line arguments with Clojure&lt;/a&gt;. It's a good article and you should read it if the idea of building command line utilities in Clojure floats your boat.&lt;/p&gt;&lt;p&gt;To complement that article I've decided to take the building of the command line app one step further and support running your creation as a standalone command. Of course its possible, as demonstrated in the article, to run the app using Leiningen directly but you typically want to be bundling your app into a self conatined package (minus any necessary runtimes - in our case the JVM) for deployment to other environments.&lt;/p&gt;&lt;p&gt;So lets start were Ryans article left off, a simple command line app that can be run via Leiningen. The &lt;code&gt;core.clj&lt;/code&gt; looks like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;runs.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;clojure.tools.cli&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cli&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:gen-class&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;-main&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;args&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;opts&lt;/span&gt; &lt;span class="nv"&gt;args&lt;/span&gt; &lt;span class="nv"&gt;banner&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cli&lt;/span&gt; &lt;span class="nv"&gt;args&lt;/span&gt;
                                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"-h"&lt;/span&gt; &lt;span class="s"&gt;"--help"&lt;/span&gt; &lt;span class="s"&gt;"Print this help"&lt;/span&gt;
                                 &lt;span class="ss"&gt;:default&lt;/span&gt; &lt;span class="nv"&gt;false&lt;/span&gt; &lt;span class="ss"&gt;:flag&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:help&lt;/span&gt; &lt;span class="nv"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;banner&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the &lt;code&gt;project.clj&lt;/code&gt; looks like this&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defproject &lt;/span&gt;&lt;span class="nv"&gt;runs&lt;/span&gt; &lt;span class="s"&gt;"0.1.0-SNAPSHOT"&lt;/span&gt;
  &lt;span class="ss"&gt;:description&lt;/span&gt; &lt;span class="s"&gt;"FIXME: write description"&lt;/span&gt;
  &lt;span class="ss"&gt;:url&lt;/span&gt; &lt;span class="s"&gt;"http://example.com/FIXME"&lt;/span&gt;
  &lt;span class="ss"&gt;:license&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="s"&gt;"Eclipse Public License"&lt;/span&gt;
            &lt;span class="ss"&gt;:url&lt;/span&gt; &lt;span class="s"&gt;"http://www.eclipse.org/legal/epl-v10.html"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="ss"&gt;:dependencies&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojure&lt;/span&gt; &lt;span class="s"&gt;"1.5.1"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/tools.cli&lt;/span&gt; &lt;span class="s"&gt;"0.2.4"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="ss"&gt;:main&lt;/span&gt; &lt;span class="nv"&gt;runs.core&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As Ryans article mentions we can run this via &lt;code&gt;lein run&lt;/code&gt; and pass our arguments in.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein run -- -h
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Uberjar&lt;/h2&gt;&lt;p&gt;First thing we want to do is take Leiningen out of the equation and bundle the app as a standalone JAR. Unlike other JVM build tools that need to be extended with plugins such as &lt;a href="http://maven.apache.org/plugins/maven-shade-plugin/"&gt;shade&lt;/a&gt;, &lt;a href="http://one-jar.sourceforge.net/"&gt;onejar&lt;/a&gt; and &lt;a href="https://github.com/sbt/sbt-assembly"&gt;assembly&lt;/a&gt; Leingingen comes with &lt;code&gt;uberjar&lt;/code&gt; prebundled. To create a basic uberjar, a JAR containting your application code and all the necessary dependencies, we can call &lt;code&gt;lein uberjar&lt;/code&gt;. There are also a bunch of configuration options that go along with uberjar but what we have specified is sufficient to build our jar. The JAR will be output to &lt;code&gt;target&lt;/code&gt; dir appended with &lt;code&gt;-standalone&lt;/code&gt;. We can run this JAR using via the usual Java way&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;java -jar target/app-0.1.0-SNAPSHOT-standalone.jar -h
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;lein-bin&lt;/h2&gt;&lt;p&gt;I don't know about you but I'm lazy and I like my commands names to represent what they do (roughly) so the thought of running &lt;code&gt;java -jar blahblah.jar -h&lt;/code&gt; every time I want to run the command is just "meh". We could write a shell script to run the more verbose command but thats less than ideal (it's messy and on top of my laziness I'm a tad OCD about carting around wrapper scripts).&lt;/p&gt;&lt;p&gt;Enter &lt;a href="https://github.com/Raynes/lein-bin"&gt;lein-bin&lt;/a&gt; a Leiningen plugin that utilises the fact ZIP files and therefore JARs can have stuff prepended to the front of it. What it does is prepend shell commands to your JAR making it executable in and of itself.&lt;/p&gt;&lt;p&gt;So to use &lt;code&gt;lein-bin&lt;/code&gt; we need to add the plugin to our projects &lt;code&gt;project.clj&lt;/code&gt; or the global Leiningen profile (&lt;code&gt;~/.lein/profiles.clj&lt;/code&gt;)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:plugins&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lein-bin&lt;/span&gt; &lt;span class="s"&gt;"0.3.4"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also add some &lt;code&gt;lein-bin&lt;/code&gt; related configuration like changing the output name (there are some other options as well, all noted in the &lt;code&gt;lein-bin&lt;/code&gt; &lt;a href="https://github.com/Raynes/lein-bin/blob/master/README.markdown"&gt;README&lt;/a&gt;)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:bin&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="s"&gt;"runs"&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So running &lt;code&gt;lein bin&lt;/code&gt; now leaves us with another file in &lt;code&gt;target&lt;/code&gt; called &lt;code&gt;runs&lt;/code&gt; that is executable.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="nv"&gt;target/runs&lt;/span&gt; &lt;span class="nv"&gt;-h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we've got a command line util called &lt;code&gt;runs&lt;/code&gt; (yeah a terrible name) rather than some verbose Java command or being force to use a build tool on all environments. It's the little things.&lt;/p&gt;</content></entry><entry><title>Adventures in Clojure Land</title><updated>Sat Jan 18 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/01/18/adventures-in-clojure-land/"></link><id>urn:yobriefca-se:feed:post:Adventures in Clojure Land</id><content type="html">&lt;p&gt;Over the last few evenings I've built a very simple application using an exclusivley Clojure stack. This is my attempt to reason about that experience. It's not supposed to be a tutorial/how-to and should be taken as "here a some things I looked at and found interesting/useful, look at them too". If you want to see the resultant code you can get it via the &lt;a href="github.com/kouphax/depression-test"&gt;depression-test repo&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;I've dabbled in &lt;a href="http://clojure.org/"&gt;Clojure&lt;/a&gt; a few times in the past but nothing even slightly serious and usually going no further than some REPL tinkering so most of this was still very new to me. In fact my previous SSD died a horrible death so I even started on a fresh machine. I decided to approach the experience by intentionally over-engineering the solution, I included libraries that I really didn't need for such a small scale solution. I did this because there is an associated cost of entry for each new library you use and the increased surface area I was exposing myself to meant I'd feel pain that basic "Hello World" examples don't really give you.&lt;/p&gt;&lt;h2&gt;Tech Stack&lt;/h2&gt;&lt;p&gt;In terms of the tech stack I ended up using I had,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://leiningen.org/"&gt;Leiningen&lt;/a&gt; - the build to of the Clojure world. Also included a few plugins,&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/weavejester/lein-ring"&gt;lein-ring&lt;/a&gt; - start/stop your ring based apps&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/emezeske/lein-cljsbuild"&gt;lein-cljsbuild&lt;/a&gt; - compile your ClojureScript into JavaScript&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/ring-clojure/ring"&gt;Ring&lt;/a&gt; - Web server/middelware library (like &lt;code&gt;connect&lt;/code&gt; in the node.js world)&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/weavejester/compojure"&gt;Compojure&lt;/a&gt; - Routing library that works well with Ring&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/weavejester/hiccup"&gt;Hiccup&lt;/a&gt; - DSL for building HTML pages/snippets in Clojure&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://clojure-liberator.github.io/liberator/"&gt;Liberator&lt;/a&gt; - library for building RESTful web apps.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/clojure/clojurescript"&gt;ClojureScript&lt;/a&gt; - I decided to build the front end interactions with ClojureScript and a few libraries,&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://facebook.github.io/react/"&gt;react.js&lt;/a&gt; - shiny new JS framework for building UIs&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://holmsand.github.io/cloact/"&gt;cloact&lt;/a&gt; - a clojurescript-ified library on top of react.js&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/yogthos/cljs-ajax"&gt;cljs-ajax&lt;/a&gt; - a neater ajax library&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Leiningen &amp;amp; Plugins&lt;/h3&gt;&lt;p&gt;Lein appears to be the defacto build tool for Clojure projects. Yes, you can use Maven or Gradle or whatever but there are certain benefits to using Lein.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Its written with Clojure projects in mind so fits better&lt;/li&gt;
  &lt;li&gt;The build file &lt;code&gt;project.clj&lt;/code&gt; is just a Clojure data structure and incredibly easy to grok when in the Clojure mindset&lt;/li&gt;
  &lt;li&gt;It feels, in my limited exposure, really simple. Dependency resolution, adding new plugins, using custom templates or generators to structure new apps - all of it "just works". Admitedly I didn't do an awful lot with it but having done plenty of work with &lt;code&gt;SBT&lt;/code&gt; and Maven it was incredibly simple but no less powerful to use.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href="https://github.com/emezeske/lein-cljsbuild"&gt;lein-cljsbuild&lt;/a&gt; feel essential when working with ClojureScript. It seems to be the only tools that transpiles ClojureScript in JavaScript.&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/weavejester/lein-ring"&gt;lein-ring&lt;/a&gt; is nice for getting up and running quickly but having just took a stab at deploying my app to &lt;a href="http://www.heroku.com"&gt;Heroku&lt;/a&gt; it appears to be a bit troublesome down the line (though most likely down to my inexperience).&lt;/p&gt;&lt;h3&gt;Ring, Compojure &amp;amp; Hiccup&lt;/h3&gt;&lt;p&gt;I'd not be suprised to find that this trio underpinned most Clojure based web apps. Seems like a brilliant combination that works really well together. While my app doesn't use ring directly it's no less essential and as your app grows you'll invariably find yourself adding ring middleware directly to customise your app. Compojure is excellent for succintly expressing the routes in your app.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defroutes&lt;/span&gt; &lt;span class="nv"&gt;app-routes&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="s"&gt;"/"&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nv"&gt;views/index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;ANY&lt;/span&gt; &lt;span class="s"&gt;"/questions"&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nv"&gt;resources/questions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;route/resources&lt;/span&gt; &lt;span class="s"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;route/not-found&lt;/span&gt; &lt;span class="s"&gt;"Not Found"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this small sample alone I'm using the &lt;code&gt;defroutes&lt;/code&gt; macro, &lt;code&gt;GET&lt;/code&gt; &amp;amp; &lt;code&gt;ANY&lt;/code&gt; verbs, the &lt;code&gt;route/resources&lt;/code&gt; handler for serving static assets and the &lt;code&gt;route/not-found&lt;/code&gt; handler for dealing with 404's in a custom way. Even with my novice mind this was incredibly easy to construct and easy to read. These routes are then turned into just another bit of ring middleware and added to the stack,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;app&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;handler/site&lt;/span&gt; &lt;span class="nv"&gt;app-routes&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;app&lt;/code&gt; here referes back to the configuration in my &lt;code&gt;project.clj&lt;/code&gt; that the &lt;code&gt;lein-ring&lt;/code&gt; plugin uses to mount our application in the web server&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:ring&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:handler&lt;/span&gt; &lt;span class="nv"&gt;depression-test.core/app&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;handler/site&lt;/code&gt; part simply wraps our routes in more ring middleware that are common to web sites (e.g. middleware for extracting HTTP post form parameters etc.)&lt;/p&gt;&lt;p&gt;Finally hiccup gives use a Cloure DSL for building HTML blocks and pages. The &lt;code&gt;index&lt;/code&gt; view is built with it,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nb"&gt;index &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;html5&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:head&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:title&lt;/span&gt; &lt;span class="s"&gt;"depression-test"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:body&lt;/span&gt;
              &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:div#stage&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;include-js&lt;/span&gt; &lt;span class="s"&gt;"/app/app.js"&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While this page is essentially static an culd easily be represented as an embedded resource you can see that this sort of expressive DSL allows us to dynamically construct views because, as is incredibly common in Clojure, it's just data.&lt;/p&gt;&lt;h3&gt;Liberator&lt;/h3&gt;&lt;p&gt;The inclusion of Liberator here was overkill but it was extracted from a slightly larger project I started at the same time as this. Liberator sits on to top of ring and focuses on allowing you to build RESTful APIs using a ridiculously easy to reason about structure. Usually when I work with frameworks or libraries that attempt to model RESTful APIs in a generic way theyend up being incredibly complex. Liberator is quite the opposite,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defresource&lt;/span&gt; &lt;span class="nv"&gt;questions&lt;/span&gt;
  &lt;span class="c1"&gt;;; return all the people in the application in json format&lt;/span&gt;
  &lt;span class="ss"&gt;:available-media-types&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"application/json"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="ss"&gt;:handle-ok&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;data/questions&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;defresource&lt;/code&gt; is a macro used to generate a resource that can be used in a route. In fact my &lt;code&gt;(ANY "/questions" [] resources/questions)&lt;/code&gt; route is basically taking any request to the &lt;code&gt;/questions&lt;/code&gt; URI and letting liberator deal with it. Our resource definition simply specifies that this endpoint can deal with JSON media types and will coerce our &lt;code&gt;questions&lt;/code&gt; list into a JSON response. It does this thanks to a bunch of defaults and an incredibly predicatable decision tree. If you want to accept different verbs, handle authentication etc. the approach to doing it is straight forward. Liberator have went to the effort of mapping the decision required to the turn our above resource into a JSON reponse via the &lt;a href="http://clojure-liberator.github.io/liberator/assets/img/decision-graph.svg"&gt;mind boggilingly awesome decision graph&lt;/a&gt; which will show you what hooks and behaviours you can work with to make the magic happen in your RESTful API. I feel Liberator is one of those important technologies. I've built a lot of APIs in recent times and the sheer "obviousness" of Liberator is the polar opposite of the unpredictable magic in many other frameworks.&lt;/p&gt;&lt;h3&gt;React.js&lt;/h3&gt;&lt;p&gt;Everyone is talking about react.js - the new hotness from Facebook. I'll not dwell to much on it. I recommend to you check out &lt;a href="http://www.youtube.com/watch?v=x7cQ3mrcKaY"&gt;this video&lt;/a&gt; around the design decisions of react and how its avoiding the usual terribleness of two-way data binding and state management. While my resultant app doesn't use react directly I did originally write the UI in Javascript/React before re-writing it in ClojureScript/cloact.&lt;/p&gt;&lt;h3&gt;Cloact&lt;/h3&gt;&lt;p&gt;One of many ClojureScript wrappers around React. This one appeared the most straight forward. It uses it's own &lt;code&gt;atom&lt;/code&gt; implementation to manage state and change propogation&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;depression-test.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cloact.core&lt;/span&gt; &lt;span class="ss"&gt;:as&lt;/span&gt; &lt;span class="nv"&gt;cloact&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;atom&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;selections&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;atom&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="nv"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nv"&gt;selections&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;fn &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By declaring &lt;code&gt;selections&lt;/code&gt; as a cloact &lt;code&gt;atom&lt;/code&gt; then later using the atom api (&lt;code&gt;swap!&lt;/code&gt;) to change its value any cloact component that uses the selections atom will get re-rendered throught the usual react method. The &lt;code&gt;render-component&lt;/code&gt; method of cloact kicks everything into action,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cloact/render-component&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:div.questions&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:h1&lt;/span&gt; &lt;span class="s"&gt;"Could you be depressed?"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:p&lt;/span&gt; &lt;span class="s"&gt;"This test will help you to assess whether you could be suffering from depression."&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:p&lt;/span&gt; &lt;span class="s"&gt;"Answer the questions based on how you've been feeling during the last two weeks."&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;score&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;.-body&lt;/span&gt; &lt;span class="nv"&gt;js/document&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;cljs-ajax&lt;/h3&gt;&lt;p&gt;Nice little shim over the normal ClojureScript ajax stuff. Not much else to say,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;load-questions&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="s"&gt;"/questions"&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:response-format&lt;/span&gt; &lt;span class="ss"&gt;:json&lt;/span&gt;
                     &lt;span class="ss"&gt;:keywords?&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt;
                     &lt;span class="ss"&gt;:handler&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;callback&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)}))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;IDE/Editor&lt;/h2&gt;&lt;p&gt;I ended up writing most of the code in Sublime Text 2. I've never quite got my Vim setup right on this new machine and I've no clue about Emacs and ST2 did the job. I installed a few plugins to make working with a LISP a bit nicer.&lt;/p&gt;&lt;h3&gt;&lt;a href="https://github.com/wuub/SublimeREPL"&gt;SublimeREPL&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Interactive REPL for Sublime that supports, among many other things, Clojure and ClojureScript. The REPL is where you end up doing most of the work in Clojure eventually pasting the same code into a file when you are done. SublimeREPL supports leiningen so you have access to your dependencies and app code when working in the REPL.&lt;/p&gt;&lt;h3&gt;&lt;a href="https://github.com/odyssomay/paredit"&gt;Paredit&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Paredit mode comes from Emacs and makes working with LISPs parenthesis a bit easier by making sure you can unbalance your braces.&lt;/p&gt;&lt;h3&gt;&lt;a href="https://github.com/odyssomay/sublime-lispindent"&gt;lispindent&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Provides more lispified logic for dealing with indenting.&lt;/p&gt;&lt;p&gt;All of these are installed via the Sublime Text package manager.&lt;/p&gt;&lt;h2&gt;Thoughts &amp;amp; Comments&lt;/h2&gt;&lt;h3&gt;Clojure&lt;/h3&gt;&lt;p&gt;Clojure is a LISP and immediatley feels different to every other language I commonly use, but regardless, when you actually work with it there is a certain feeling of "naturalness" about the whole thing. The homoiconic nature, where "everything is just data" means that solving problems is suprisingly intuative and this applies to using libraries and frameworks. Most things are just lists and maps and you can inspect these things easily in the REPL. The amount of experimental spikes that work more or less first time is incredibly high and the final code is usually very terse. I'm by no means an expert, not even "average" at Clojure but it's a joy to use thanks to its well thought out foundation.&lt;/p&gt;&lt;p&gt;Another thing I've noticed is that Clojure libs dont suffer from the same API volatility that you see in likes of Node and Ruby. For example some popular libraries haven't had commits in 7 months - and it's not because they have stagnated or been neglected - it's because they're done. IMHO thats the sign of an incredibly mature, design concious community.&lt;/p&gt;&lt;p&gt;That said - some documentation leaves a lot to be desired if it even exists. I did often find myself searching to try and find what I wanted to know and usually resulted in just reading the code.&lt;/p&gt;&lt;h3&gt;ClojureScript&lt;/h3&gt;&lt;p&gt;I enjoyed working with ClojureScript but I didn't quite get my workflow right. ClojureScript takes a while to compile but this can be automated. Problem was I couldn't get this automation to work with &lt;code&gt;lein-ring&lt;/code&gt; and so I found my self waiting ~20 seconds to try each change - it's cool though, I write Scala regularly. That said ClojureScript intrigues me more than any of the other JS transpilers around - I very quickly stopped seeing the point of CoffeeScript for example. The fact it works well with node.js (ClojureScript all the way down) is equally interesting.&lt;/p&gt;&lt;h2&gt;Onward&lt;/h2&gt;&lt;p&gt;Clojure, which was/is, very new to me helped me put together a simple application rather quickly as to how it stands up against larger projects remains to be seen. I'm going to try and see if I can improve my ClojureScript workflow as its a rather compelling technology but right now its a bit slow to use (e.g. I got better results using &lt;a href="https://github.com/swannodette/mies"&gt;meis&lt;/a&gt; and &lt;code&gt;lein cljsbuild auto&lt;/code&gt; but that skipped the server stuff). I also need to re-work this app to work on heroku without sacrificing the ease of &lt;code&gt;lein ring server&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Its worth caveating that the &lt;a href="github.com/kouphax/depression-test"&gt;code&lt;/a&gt; should in no way be assumed to be best practise, in fact its probably awful.&lt;/p&gt;</content></entry></feed>