<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:clojurescript</id><updated>Mon Jul 20 00:00:00 UTC 2015</updated><title type="text">Yo! Briefcase: clojurescript</title><link rel="self" href="https://yobriefca.se/feed/clojurescript.xml"></link><entry><title>Zombie Dice Score Card</title><updated>Mon Jul 20 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://github.com/kouphax/zombie-dice"></link><id>urn:yobriefca-se:feed:post:Zombie Dice Score Card</id><content type="html"></content></entry><entry><title>Zombie Dice Score Card with Reagent</title><updated>Mon Jul 20 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/07/20/zombie-dice-score-card-with-reagent/"></link><id>urn:yobriefca-se:feed:post:Zombie Dice Score Card with Reagent</id><content type="html">&lt;p&gt;Over the weekend I built a &lt;a href="/zombie-dice"&gt;Zombie Dice Score Card&lt;/a&gt;. I built it because I keep forgetting to get pen and paper for keeping score but mostly because I wanted to build something simple in ClojureScript again.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/zombie-dice.png" alt="Zombie Dice Score Card" _="_" /&gt;&lt;/p&gt;&lt;p&gt;The app is pretty basic, no server side interaction, no local storage interaction and only a few basic actions/features. You simply,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Add players&lt;/li&gt;
  &lt;li&gt;Play zombie dice as usual, rewarding points by clicking the necessary brain on the screen.&lt;/li&gt;
  &lt;li&gt;When someone reaches 13 brains you'll be told to finish the round (all remaining players yet to go on this round have a final chance at stealing the win)&lt;/li&gt;
  &lt;li&gt;Hitting 'Finish Game' will reward the person with the highest number of brains a gold brain and the next game begins.&lt;/li&gt;
  &lt;li&gt;At any time you can reset the current game scores or clear the entire board.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;For the curious the stack used is as follows,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ClojureScript&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/martinklepsch/tenzing"&gt;Tenzing&lt;/a&gt; - Leiningen template for creating Boot powered client side only ClojureScript applications.&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://boot-clj.com/"&gt;Boot&lt;/a&gt; - The new build system on the Clojure(Script) block offering a more programatic approach to build systems (i.e more like Rake than Maven)&lt;/li&gt;
  &lt;li&gt;&lt;a href="http://reagent-project.github.io/"&gt;Reagent&lt;/a&gt; - A simple ClojureScript wrapper around &lt;a href="http://facebook.github.io/react/"&gt;React&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/lbradstreet/cljs-uuid-utils"&gt;cljs-uuid-utils&lt;/a&gt; - ClojureScript library for generating and working with UUID's&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Tenzing&lt;/h2&gt;&lt;p&gt;This is a nice little template for prototyping with ClojureScript or in situations where you can integrate with external services for your server side needs. It's a conditional template that lets you add technologies that you think you'll need. For example I generated the Zombie Dice Score Card project with,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;lein new tenzing zombie-dice +sass +reagent +divshot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This template gives me an app with &lt;code&gt;SASS&lt;/code&gt;, &lt;code&gt;Reagent&lt;/code&gt; and &lt;a href="https://divshot.com/"&gt;Divshot&lt;/a&gt; configuration and all the necessary build pipeline stuff set up to compile CLJS and SASS when files change. I didn't use &lt;a href="https://divshot.com/"&gt;Divshot&lt;/a&gt; this time around but it's nice to know the option was there.&lt;/p&gt;&lt;p&gt;On another note I did find it a bit weird using Leiningen to generate a Boot application but I guess most Clojure(Script) developers are going to have Leiningen available and Boot doesn't provide templating support.&lt;/p&gt;&lt;h2&gt;Boot&lt;/h2&gt;&lt;p&gt;I didn't need to dive into Boot too much for this tiny project but I do like what I see. The way tasks are defined in Clojure and composed into pipelines using standard Clojure idioms makes creating build pipelines really rather nice.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;deftask&lt;/span&gt; &lt;span class="nv"&gt;build&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;speak&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cljs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sass&lt;/span&gt; &lt;span class="ss"&gt;:output-dir&lt;/span&gt; &lt;span class="s"&gt;"css"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;deftask&lt;/span&gt; &lt;span class="nv"&gt;run&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;comp &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;serve&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cljs-repl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;build&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You see &lt;code&gt;run&lt;/code&gt; composes a pipeline of other tasks for serving the application, watching for filesystem changes, connecting to a ClojureScript REPL and reloading the application. It then composes another defined task for building the ClojureScript and SASS.&lt;/p&gt;&lt;h2&gt;Reagent&lt;/h2&gt;&lt;p&gt;Aside from a name change Reagent (formerly Cloact) hasn't really change that much since I talked about in &lt;a href="https://yobriefca.se/blog/2014/01/18/adventures-in-clojure-land/"&gt;January 2014&lt;/a&gt;. Sure they've added some new features and refined the API a bit but its approach is still the same. It provides simple approach to using React in a ClojureScript app offering us hiccup style syntax for declaring components along side atoms for state management.&lt;/p&gt;&lt;p&gt;I've never really looked into the other React wrappers so I can't speak to whether Reagent is the best but I can say it's certainly been a pleasure to use on small scale apps.&lt;/p&gt;&lt;h2&gt;Source&lt;/h2&gt;&lt;p&gt;The source for the app is available, as always, on &lt;a href="https://github.com/kouphax/zombie-dice/"&gt;Github&lt;/a&gt; and I welcome any feedback or advice you may have.&lt;/p&gt;&lt;h2&gt;Plans&lt;/h2&gt;&lt;p&gt;I think I'm going to write this in Elm just to see what all the fuss is about. Maybe add some local storage for saving historical games and players. Truth be told I'll probably never touch it again but a man can dream.&lt;/p&gt;&lt;h2&gt;Footnote&lt;/h2&gt;&lt;p&gt;Have you ever played &lt;a href="http://www.sjgames.com/dice/zombiedice/"&gt;Zombie Dice&lt;/a&gt;? If not you should give it a go it's a simple, quick dice based game that you can explain in about 3 minutes and have a full game done in about 15 or 20 minutes. The aim is simple, try and collect/eat 13 brains by rolling dice over a series of rounds. Once someone hits 13 brains everyone finishes that round and the person that has the highest score wins that game. Typically you play best of 3 or 5 games.&lt;/p&gt;</content></entry><entry><title>Publish and Subscribe with core.async's pub and sub</title><updated>Wed Jun 04 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/06/04/publish-and-subscribe-with-core-dot-asyncs-pub-and-sub/"></link><id>urn:yobriefca-se:feed:post:Publish and Subscribe with core.async's pub and sub</id><content type="html">&lt;p&gt;Following on from my &lt;a href="/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"&gt;previous article&lt;/a&gt; that covered &lt;code&gt;core.async&lt;/code&gt;'s &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; this article will delve into another suite of complementary &lt;strong&gt;high level&lt;/strong&gt; methods - namely the channel driven publish/subscribe model that &lt;code&gt;core.async&lt;/code&gt; can support.&lt;/p&gt;&lt;p&gt;While the pub/sub mechanism provided by core.async is higher level than working directly with &lt;code&gt;chan&lt;/code&gt;s and &lt;code&gt;mult&lt;/code&gt;s to achieve the same thing (in fact that is how the pub/sub operations are implemented internally) it should still be considered a set of lower level primitives compared to say a specific event bus notification with topic namespacing, wildcard broadcasting and other such specialised features.&lt;/p&gt;&lt;p&gt;I've attempted to visualise how the various parts of a pub/sub setup would interact. We'll use this as a starting point and expand on how this all falls together through the course of the article.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/pubsub.png" alt="Pub Sub" _="_" /&gt;&lt;/p&gt;&lt;h2&gt;Setup&lt;/h2&gt;&lt;p&gt;Once again we'll use ClojureScript to demonstrate the use of pub/sub. I'll refer you the &lt;strong&gt;Setting Up&lt;/strong&gt; section of my &lt;a href="/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"&gt;previous article&lt;/a&gt; if you want to get a basic ClojureScript setup running with &lt;code&gt;core.async&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;Publishing&lt;/h2&gt;&lt;p&gt;Channels are &lt;code&gt;core.async&lt;/code&gt;s foundation and this is no different when you move up a level of abstraction to a pub/sub model. Looking at the publishing side first there are 2 main types of actors or components involved,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The publisher channel - Putting stuff on this channel will cause the publishing mechanism to kick in&lt;/li&gt;
  &lt;li&gt;The publication - calling &lt;code&gt;pub&lt;/code&gt; on the publisher (we'll see this in a minute) produces a &lt;code&gt;publication&lt;/code&gt; that subscribers can &lt;code&gt;sub&lt;/code&gt;/subscribe to.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;This may appear a bit more jarring than a typical approach where you just have a monolithic pub/sub object (e.g. a bus) that you publish and subscribe to directly. However I found the idea a bit easier to understand when I thought of the publication as a realised &lt;strong&gt;topic&lt;/strong&gt; or set of &lt;strong&gt;topics&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;If you think of a simple message bus implementation (in whatever language floats your boat - I've went with Swift, nah just kidding its JavaScript) you would traditionally do something like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="javascript"&gt;&lt;span class="c1"&gt;// grab/create a bus - typically global.&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;bus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Bus&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nx"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"account:created"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
  &lt;span class="c1"&gt;// do something with the knowledge that&lt;/span&gt;
  &lt;span class="c1"&gt;// an account has been created&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;// at some point we publish to the same topic&lt;/span&gt;
&lt;span class="nx"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"acoount:created"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;success&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nx"&gt;username&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"petedaleet17"&lt;/span&gt;
&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The topic in this example is &lt;code&gt;account:created&lt;/code&gt; however in reality its just a string, there is no real confidence that you are achieving what you expect. A spelling error will result in rather unpredictable results and as we have introduced a high degree of decoupling it may well be difficult to track down. The observant will notice there is in fact a spelling error in the code.&lt;/p&gt;&lt;p&gt;In &lt;code&gt;core.async&lt;/code&gt; the notion of a &lt;code&gt;publication&lt;/code&gt; is a realised entity you perform actions on and pass around. It's the transport mechanism, that is the "concept". This inversion is interesting. 99.9% of the time I'm ultimately interested in publishing or subscribing to a topic, I really don't care about the mechanics of that operation and this &lt;strong&gt;topic-first&lt;/strong&gt; view better supports that thought model.&lt;/p&gt;&lt;p&gt;Now just to confuse things a bit more, a publication also defines a way to derive the topic of a published value so its entirely possible for a publication to handle subscriptions for any number of topics. Another analogy that may help, or just make things worse, is that a &lt;code&gt;publication&lt;/code&gt; could be considered a &lt;code&gt;router&lt;/code&gt; that defines a set of rules for where to publish data.&lt;/p&gt;&lt;p&gt;To expand on this lets look at some code.&lt;/p&gt;&lt;p&gt;First we need to import a few things into out ClojureScript file (probably &lt;code&gt;core.cljs&lt;/code&gt;)&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;chat.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;chan&lt;/span&gt; &lt;span class="nv"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;timeout&lt;/span&gt; &lt;span class="nv"&gt;pub&lt;/span&gt; &lt;span class="nv"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;unsub&lt;/span&gt; &lt;span class="nv"&gt;unsub-all&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require-macros&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async.macros&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;go&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now lets introduce our publisher and our publication,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; publisher is just a normal channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; publication is a thing we subscribe to&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;publication&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pub&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can see the &lt;code&gt;publisher&lt;/code&gt; is simply a channel, no fancy annotations or extra functions being applied. It's just a vanilla channel that you can put stuff and take stuff off if you so desired.&lt;/p&gt;&lt;p&gt;The &lt;code&gt;publication&lt;/code&gt; ont he other hand is composed by calling &lt;code&gt;pub&lt;/code&gt; on &lt;code&gt;publisher&lt;/code&gt; passing a function. When you put stuff onto &lt;code&gt;publisher&lt;/code&gt; this function is used to derive the topic of the data put onto the channel. It will get passed the put data and is expected to return &lt;strong&gt;something&lt;/strong&gt;, &lt;strong&gt;anything&lt;/strong&gt; that represents the topic.&lt;/p&gt;&lt;p&gt;In this case I am making an assumption that our data will be a map with a &lt;code&gt;:topic&lt;/code&gt; entry. Of course if &lt;code&gt;(:topic data)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; that will be our topic. Any topics that have no subscribers will be disregarded so &lt;code&gt;nil&lt;/code&gt; will typically be an acceptable &lt;strong&gt;dead letter office&lt;/strong&gt; so to speak.&lt;/p&gt;&lt;h2&gt;Subscribing&lt;/h2&gt;&lt;p&gt;So now we have something we can push data onto - the &lt;code&gt;publisher&lt;/code&gt; channel, and something that will accept subscriptions - the &lt;code&gt;publication&lt;/code&gt;. Next we need to subscribe and start putting stuff on that our subscribers can consume. We could start putting stuff on the channel now but no one will be around to receive it just yet.&lt;/p&gt;&lt;p&gt;The yin to &lt;code&gt;pub&lt;/code&gt;s yang is &lt;code&gt;sub&lt;/code&gt;. &lt;code&gt;sub&lt;/code&gt; always takes a &lt;strong&gt;publication&lt;/strong&gt;, a &lt;strong&gt;topic&lt;/strong&gt; and a &lt;strong&gt;channel&lt;/strong&gt; (you can also specify how and when the subscribing channel will be closed). As I've already mentioned you'll notice that the subscriber channels don't subscribe directly to the publisher channel. This would allow you to create many publications from a single source channel.&lt;/p&gt;&lt;p&gt;Taking our previous example we could subscribe to a number of topics like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; define a bunch of subscribers&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-one&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-two&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;subscriber-three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; subscribe&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt;  &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt;     &lt;span class="nv"&gt;subscriber-three&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We now have 3 channels&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;subscriber-one&lt;/code&gt; is subscribed to the &lt;code&gt;:account-created&lt;/code&gt; topic&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;subscriber-two&lt;/code&gt; is subscribed to both the &lt;code&gt;:account-created&lt;/code&gt; topic and the &lt;code&gt;:user-logged-in&lt;/code&gt; topic&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;subscriber-three&lt;/code&gt; is subscribed to the &lt;code&gt;:change-page&lt;/code&gt; topic&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Now when messages are put on to the &lt;code&gt;publisher&lt;/code&gt; the &lt;code&gt;publication&lt;/code&gt; will inspect the data and determine where to route the message. To make this more visual we can listen to and print the values from these channels by trying to take from them in a &lt;code&gt;go-loop&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;take-and-print&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go-loop&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="nv"&gt;prefix&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-one&lt;/span&gt; &lt;span class="s"&gt;"subscriber-one"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt; &lt;span class="s"&gt;"subscriber-two"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;take-and-print&lt;/span&gt; &lt;span class="nv"&gt;subscriber-three&lt;/span&gt; &lt;span class="s"&gt;"subscriber-three"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we start putting messages on the publisher we should see some console output.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt; &lt;span class="ss"&gt;:dest&lt;/span&gt; &lt;span class="s"&gt;"/#home"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-three: { :topic :change-page :dest "/#home" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-one: { :topic :account-created :username "billy" }&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-two: { :topic :account-created :username "billy" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-two: { :topic :user-logged-in :username "billy" }&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-out&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; No subscribers so nothing to see&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course subscribing to something is entirely additive. You need some way to take subscriptions away. At this point &lt;code&gt;unsub&lt;/code&gt; and &lt;code&gt;unsub-all&lt;/code&gt; are what you need.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; unsubscribe subscriber-two from account-created&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="nv"&gt;subscriber-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; subscriber-one: { :topic :account-created :username "billy" }&lt;/span&gt;

&lt;span class="c1"&gt;; unsubscribe every subscriber from the :account-created topic&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub-all&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; nada&lt;/span&gt;

&lt;span class="c1"&gt;; finally unsubscribe every channel from every topic&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;unsub-all&lt;/span&gt; &lt;span class="nv"&gt;publication&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;test&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:change-page&lt;/span&gt; &lt;span class="ss"&gt;:dest&lt;/span&gt; &lt;span class="s"&gt;"/#home"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:account-created&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-in&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;publisher&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:topic&lt;/span&gt; &lt;span class="ss"&gt;:user-logged-out&lt;/span&gt; &lt;span class="ss"&gt;:username&lt;/span&gt; &lt;span class="s"&gt;"billy"&lt;/span&gt; &lt;span class="p"&gt;}))&lt;/span&gt;
&lt;span class="c1"&gt;; wonderful silence&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;So that covers the &lt;code&gt;pub&lt;/code&gt;/&lt;code&gt;sub&lt;/code&gt; model you get with &lt;code&gt;core.async&lt;/code&gt; which gives a slightly higher abstraction from having to deal with the internal logic of managing a &lt;code&gt;mult&lt;/code&gt; to perform this operation while still remaining suitably low level to allow you to build upon it for your own needs.&lt;/p&gt;&lt;p&gt;Remember that because everything still boils down to channels, which you have access to, there is huge potential to combine various abstractions to construct simple pipelines for all your needs.&lt;/p&gt;&lt;p&gt;One day I'll finish my channel based &lt;a href="https://en.wikipedia.org/wiki/Rube_Goldberg_machine"&gt;Rube Goldberg machine&lt;/a&gt; put a message at one end and watch as it gets piped through mults, publications, merged channels, alts and anything else I can think of finally ending up in a &lt;code&gt;console.log&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;"Hi James".&lt;/p&gt;
&lt;/blockquote&gt;</content></entry><entry><title>Combining &amp; Controlling Channels with core.async's merge and mix</title><updated>Sun Jun 01 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/06/01/combining-and-controlling-channels-with-core-dot-asyncs-merge-and-mix/"></link><id>urn:yobriefca-se:feed:post:Combining &amp; Controlling Channels with core.async's merge and mix</id><content type="html">&lt;p&gt;Most discussions around &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt;, be it in Clojure or ClojureScript, tend to focus around the key concepts of the library - specifically &lt;code&gt;chan&lt;/code&gt;s and the &lt;code&gt;go&lt;/code&gt;/&lt;code&gt;go-loop&lt;/code&gt; macros. This isn't a bad thing as that is were the power of the library comes from, on the other hand &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt; also has a few powerful higher-level features that let you do some very interesting things and they deserve a bit of love as well.&lt;/p&gt;&lt;p&gt;Two such features are &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/merge"&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; and &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/mix"&gt;&lt;code&gt;mix&lt;/code&gt;&lt;/a&gt;. Both methods have a similar goal - combining multiple input channels into a single output channel however in practise they are rather different.&lt;/p&gt;&lt;p&gt;At a high level you could draw the 2 operations like so,&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/mix-merge.png" alt="High level view of merge and mix" _="_" /&gt;&lt;/p&gt;&lt;p&gt;In fact the &lt;code&gt;mix&lt;/code&gt; diagram is slightly more complicated in reality but we can expand on that as we go.&lt;/p&gt;&lt;h2&gt;Setting up&lt;/h2&gt;&lt;p&gt;So lets look at some examples of these operations. I'm talking in the context of ClojureScript in this case but same reules and principles apply in plain Clojure.&lt;/p&gt;&lt;p&gt;If you want to try these examples and are rather new to ClojureScript I recently outlined a &lt;a href="http://yobriefca.se/blog/2014/05/30/basic-clojurescript-setup/"&gt;basic ClojureScript setup&lt;/a&gt; which will get you up and running.&lt;/p&gt;&lt;p&gt;Assuming you have an empty ClojureScript project one way or another you need to add a reference to &lt;code&gt;core.async&lt;/code&gt; in the &lt;code&gt;:dependencies&lt;/code&gt; section of the projects &lt;code&gt;project.clj&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;  &lt;span class="ss"&gt;:dependencies&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/clojurescript&lt;/span&gt; &lt;span class="s"&gt;"0.0-2173"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;org.clojure/core.async&lt;/span&gt; &lt;span class="s"&gt;"0.1.303.0-886421-alpha"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then in your ClojureScript source (probably &lt;code&gt;src/&amp;lt;project_name&amp;gt;/core.cljs&lt;/code&gt;) you need to import a few things. I'll assume you have at least a basic understanding of channels and &lt;code&gt;core.async&lt;/code&gt; already so we can just import everything we need for the examples.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ns &lt;/span&gt;&lt;span class="nv"&gt;chat.core&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;mix&lt;/span&gt; &lt;span class="nv"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;toggle&lt;/span&gt; &lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="nv"&gt;chan&lt;/span&gt; &lt;span class="nv"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;timeout&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:require-macros&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;cljs.core.async.macros&lt;/span&gt; &lt;span class="ss"&gt;:refer&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;go&lt;/span&gt;&lt;span class="p"&gt;]]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we are about ready for the examples.&lt;/p&gt;&lt;h2&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/merge"&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; is the simpler of the two features and as the API documentation says combines 1..N source channels and returns a channel which contains all values taken from them. The operation is entirely immutable. That is, once you use &lt;code&gt;merge&lt;/code&gt; to create a channel you can't add or remove channels later. When all input channels have closed the merged channel will also close.&lt;/p&gt;&lt;p&gt;This is useful when you have multiple event streams, represented as channels, and you want to process them in the same way and in a centralised manner e.g. when you are wanting to parse multiple simultaneous server requests, web socket events or user interactions from various parts of the user interface.&lt;/p&gt;&lt;p&gt;To keep the example simple we will just create 3 channels that randomly publish their names every now and then,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; declare the channels&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-one&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-two&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;in-channel-three&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; define the function for publishing&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;randomly-constantly&lt;/span&gt;
  &lt;span class="s"&gt;"Constantly publishes the given value to the given channel in random&lt;/span&gt;
&lt;span class="s"&gt;   intervals every 0-5 seconds."&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;publish-value&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;timeout&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rand-int &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;!&lt;/span&gt; &lt;span class="nv"&gt;channel&lt;/span&gt; &lt;span class="nv"&gt;publish-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;; start putting stuff on the channels&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;   &lt;span class="s"&gt;"channel-one"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;   &lt;span class="s"&gt;"channel-two"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;randomly-constantly&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt; &lt;span class="s"&gt;"channel-three"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So now we have 3 channels that will randomly have their name pushed onto them we now need to do something with them. For the sake of simplicity lets assume all we need to do is log the result. We could write 3 distinct &lt;code&gt;go&lt;/code&gt; loops (or suitably abstract it into a reusable function),&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But regardles of how much you abstract away the mechanics you are still dealing with the 3 channels as 3 distinct entities when in many cases you should be dealing with a single channel derived from multiple sources. We achieve this with &lt;code&gt;merge&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;merged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;merge &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;in-channel-one&lt;/span&gt;
                    &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;
                    &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;merged&lt;/code&gt; is now a channel that we can &lt;code&gt;take&lt;/code&gt; from and recieve values from all 3 channels. Now we can perform our &lt;code&gt;go&lt;/code&gt; loop over the single channel instead,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;merged&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/mix"&gt;&lt;code&gt;mix&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; is fine when you want to just grab a bunch of channels and treat them as one but sometimes this is not enough. When it comes to channels that produce effects visible to the user there is often a need to better control these messages. Imagine a chat application where each person is represented as a channel, or perhaps a log dashboard where each channel is a service in your system streaming log data.&lt;/p&gt;&lt;p&gt;In such situations, where the volume is high, there may be times you want to focus on a particular set of logs or chat messages, or surpress someone or something that is being particularly chatty. Maybe these messages can be discarded, maybe they are important and need to looked at later. These are the things that &lt;code&gt;merge&lt;/code&gt; fails to address. These are the things that &lt;code&gt;mix&lt;/code&gt; &lt;strong&gt;does&lt;/strong&gt; address.&lt;/p&gt;&lt;p&gt;The key differences that set &lt;code&gt;mix&lt;/code&gt; apart from &lt;code&gt;merge&lt;/code&gt; are that,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It introduces an intermediary component - the mixer&lt;/li&gt;
  &lt;li&gt;It is configurable, you can add and remove input channels&lt;/li&gt;
  &lt;li&gt;Channels can be muted, paused and solo'ed on demand&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;So lets take our 3 channels above and apply the abilities of &lt;code&gt;mix&lt;/code&gt; to the situation.&lt;/p&gt;&lt;p&gt;First of all we need to create 2 things.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The output channel - unlike &lt;code&gt;merge&lt;/code&gt; this isn't created for us&lt;/li&gt;
  &lt;li&gt;The mixer - we create this via the &lt;code&gt;mix&lt;/code&gt; method&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="c1"&gt;; manually declare our output channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;output-channel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;chan&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;; create a mixer linked to the output channel&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;mix&lt;/span&gt; &lt;span class="nv"&gt;output-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also, at this point, set up our &lt;code&gt;go&lt;/code&gt; loop for printing the data put onto the output channel&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;go&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;loop &lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;!&lt;/span&gt; &lt;span class="nv"&gt;output-channel&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recur&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unlike &lt;code&gt;merge&lt;/code&gt; we still haven't declared what input channels should be associated with the mixer and ultimately output channel. We can do this using &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/admix"&gt;&lt;code&gt;admix&lt;/code&gt;&lt;/a&gt;,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-two&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;admix&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="nv"&gt;in-channel-three&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point we should start seeing stuff being logged to the console exactly like we did with &lt;code&gt;merge&lt;/code&gt;. This is where &lt;code&gt;mix&lt;/code&gt; starts to get interesting.&lt;/p&gt;&lt;h3&gt;&lt;a href="http://clojure.github.io/core.async/#clojure.core.async/toggle"&gt;&lt;code&gt;toggle&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;toggle&lt;/code&gt; allows you to control how the mixer responds to each input channel. You pass it a state map of channels and associated mixer properties. With &lt;code&gt;toggle&lt;/code&gt; you can do any combination (though many would not make sense) of,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;:mute&lt;/code&gt; - keep taking from the input channel but discard any taken values&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:pause&lt;/code&gt; - stop taking from the input channel&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:solo&lt;/code&gt; - listen &lt;strong&gt;only&lt;/strong&gt; to this (and other &lt;code&gt;:solo&lt;/code&gt;ed channels). Whether or not the non-soloed channels are muted or paused can be controlled via the &lt;a href="http://clojure.github.io/core.async/#clojure.core.async/solo-mode"&gt;&lt;code&gt;solo-mode&lt;/code&gt;&lt;/a&gt; method.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;So lets imagine one of our mixed channels (&lt;code&gt;in-channel-one&lt;/code&gt;) it getting a bit chatty. It could swamp our logging output and we might miss something important in another channel. We can use toggle to temporarily mute it,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:mute&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now our output will only be displaying the other 2 channels. But suppose the data coming in from channel one was actually important, as it stands muting a channel simply discards any takes that happen. If we want to stop taking anything from the channel (and therefore allow it to buffer on the channel) we can pause the channel instead.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:mute&lt;/span&gt;  &lt;span class="nv"&gt;false&lt;/span&gt;
                                 &lt;span class="ss"&gt;:pause&lt;/span&gt; &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally if we want to &lt;strong&gt;only&lt;/strong&gt; concern ourselves with channel one we can &lt;code&gt;solo&lt;/code&gt; it&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;toggle&lt;/span&gt; &lt;span class="nv"&gt;mixer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;in-channel-one&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:solo&lt;/span&gt;  &lt;span class="nv"&gt;true&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You'll notice I didn't set &lt;code&gt;:pause&lt;/code&gt; back to &lt;code&gt;false&lt;/code&gt; because soloed channels ignore their other properties..&lt;/p&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;We covered both the &lt;code&gt;merge&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; methods of &lt;code&gt;core.async&lt;/code&gt;. Both methods are higher level ways to combine and control multiple input channels into a single unified output channel.&lt;/p&gt;&lt;p&gt;&lt;code&gt;merge&lt;/code&gt; offers a simple straigthforward way to combine channels but offers you little control after the fact. &lt;code&gt;mix&lt;/code&gt; gives you greater control over the input channels and is exceptionally useful when you need to manage input streams.&lt;/p&gt;</content></entry><entry><title>Basic ClojureScript Setup</title><updated>Fri May 30 00:00:00 UTC 2014</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2014/05/30/basic-clojurescript-setup/"></link><id>urn:yobriefca-se:feed:post:Basic ClojureScript Setup</id><content type="html">&lt;p&gt;ClojureScript is a bit of an awkward one to get into. If Clojure isn't your natural language then you may well find the clojarian setup and the long compilation times a bit of a frustration. Even if you're accustomed to the REPL based development approach that fits so well with Clojure there is still a certain amount of friction to be had with ClojureScript.&lt;/p&gt;&lt;p&gt;Recently a strong desire to play with and better understand &lt;a href="https://github.com/clojure/core.async"&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/a&gt; in ClojureScript I decided to try and put together a lightweight workflow. In doing so I ended up producing a Clojure library (&lt;a href="http://yobriefca.se/primrose/"&gt;primrose&lt;/a&gt;) and a Leiningen plugin (&lt;a href="http://yobriefca.se/lein-cooper/"&gt;lein-cooper&lt;/a&gt;) to better support this workflow.&lt;/p&gt;&lt;p&gt;It's probably a sure sign that you are doing something wrong when you feel you need to create a bunch of developer focused tools to support a workflow for an already established ecosystem but you gotta do, what you gotta do.&lt;/p&gt;&lt;p&gt;Here goes.&lt;/p&gt;&lt;h2&gt;Starting point&lt;/h2&gt;&lt;p&gt;ClojureScript projects are still Clojure projects and so there are few bits and pieces that you need to wire up a basic empty project. You've got your &lt;code&gt;project.clj&lt;/code&gt;, the &lt;a href="https://github.com/emezeske/lein-cljsbuild"&gt;&lt;code&gt;lein-cljsbuild&lt;/code&gt;&lt;/a&gt; plugin for compiling ClojureScript to JavaScript and (at the very least) an &lt;code&gt;index.html&lt;/code&gt; for bringing everything together.&lt;/p&gt;&lt;p&gt;Thankfully David Nolen has you covered. &lt;a href="https://github.com/swannodette/mies"&gt;Mies&lt;/a&gt; is a very basic ClojureScript project template so getting up and running is a matter of,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein new mies &amp;lt;project name&amp;gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; &amp;lt;project name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At this point you are good to go. To compile the ClojureScript you can run,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein cljsbuild once
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you open &lt;code&gt;index.html&lt;/code&gt; and view the developer console you should see some predictable output. Alternatively if you run,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The plugin will watch your project sources and recompile everything when changes are made. This is significantly faster that manually compiling every time as compilation is incremental. So instead of 10s of seconds for each compile you'll be getting sub-second compilations.&lt;/p&gt;&lt;h2&gt;Ajax&lt;/h2&gt;&lt;p&gt;When you view HTML files via &lt;code&gt;file://&lt;/code&gt; you won't be able to, at least by default, make ajax calls (due to security concerns such as &lt;a href="https://en.wikipedia.org/wiki/Same-origin_policy"&gt;Same-origin policy&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;To fix this you'll want to serve your &lt;code&gt;index.html&lt;/code&gt; from a web server. You could go with &lt;code&gt;python -m simplehttpserver&lt;/code&gt; as many often do but if you want to keep everything under the same roof (Clojure/Leiningen) then I'd recommend &lt;a href="https://github.com/tailrecursion/lein-simpleton"&gt;&lt;code&gt;lein-simpleton&lt;/code&gt;&lt;/a&gt; - a Leiningen plugin for serving static files from the current directory. If you add &lt;code&gt;lein-simpleton&lt;/code&gt; to the projects &lt;code&gt;project.clj&lt;/code&gt; file,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:plugins&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lein-cljsbuild&lt;/span&gt; &lt;span class="s"&gt;"1.0.2"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-simpleton&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can now run &lt;code&gt;lein simpleton &amp;lt;port&amp;gt;&lt;/code&gt; to start serving static files (your &lt;code&gt;index.html&lt;/code&gt;). Alternatively if you have actual server side code in the same project you can replace &lt;code&gt;lein-simpleton&lt;/code&gt; with &lt;a href="https://github.com/weavejester/lein-ring"&gt;&lt;code&gt;lein-ring&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;Two for One&lt;/h2&gt;&lt;p&gt;So now if you run both&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;lein cljsbuild auto&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lein simpleton &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;You have a dynamic(ish) environment for working and testing your ClojureScript work.&lt;/p&gt;&lt;p&gt;Problem is I don't like having multiple windows open for long running processes and we now have 2. Ruby has a nice answer for this which plays very well with &lt;a href="http://heroku.com"&gt;Heroku&lt;/a&gt; - &lt;a href="https://github.com/ddollar/foreman"&gt;Foreman&lt;/a&gt;. Foreman takes a file (&lt;code&gt;Procfile&lt;/code&gt;) that contains a list of named command line processes and runs them. These processes are supposed to be long running (like &lt;code&gt;simpleton&lt;/code&gt; and &lt;code&gt;cljsbuild auto&lt;/code&gt;) and Foreman merges the output of these files into a single stream that makes development and debugging a bit easier.&lt;/p&gt;&lt;p&gt;Again if you want to keep this sort of thing all under one roof I've thrown together a simple plugin for ingesting a &lt;code&gt;Procfile&lt;/code&gt; and doing what Foreman does - in Leiningen.&lt;/p&gt;&lt;h2&gt;lein-cooper&lt;/h2&gt;&lt;p&gt;&lt;a href="https://github.com/kouphax/lein-cooper"&gt;&lt;code&gt;lein-cooper&lt;/code&gt;&lt;/a&gt; gives you that Foreman feeling. So lets add this as a plugin.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt;&lt;span class="ss"&gt;:plugins&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nv"&gt;lein-cljsbuild&lt;/span&gt; &lt;span class="s"&gt;"1.0.2"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-simpleton&lt;/span&gt; &lt;span class="s"&gt;"1.3.0"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;lein-cooper&lt;/span&gt; &lt;span class="s"&gt;"0.0.1"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can create a &lt;code&gt;Procfile&lt;/code&gt; at the root of our project to run our two commands.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;web: lein simpleton
cljs: lein cljsbuild auto
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now if we run &lt;code&gt;lein cooper&lt;/code&gt; we will have single call to start up our dynamic(ish) environment for working with ClojureScript. Once you are done just &lt;code&gt;CTRL-C&lt;/code&gt; the terminal and everything will shutdown cleanly.&lt;/p&gt;&lt;h2&gt;Summing Up&lt;/h2&gt;&lt;p&gt;So we now have a very basic project setup that will allow us to tinker with ClojureScript, make Ajax calls, edit code and cleanly automate away all the stopping and restarting and problematic debugging. It's not quite the REPL driven style of a typical Clojure project but it's minimal enough to try a few smaller scale things.&lt;/p&gt;</content></entry></feed>