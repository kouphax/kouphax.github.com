<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:crystal</id><updated>Thu Jan 14 00:00:00 UTC 2016</updated><title type="text">Yo! Briefcase: crystal</title><link rel="self" href="https://yobriefca.se/feed/crystal.xml"></link><entry><title>alias, union and case in Crystal</title><updated>Thu Jan 14 00:00:00 UTC 2016</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2016/01/14/alias-union-and-case-in-crystal/"></link><id>urn:yobriefca-se:feed:post:alias, union and case in Crystal</id><content type="html">&lt;p&gt;So I've been diving into Crystal lately. It's nice. This isn't a post about why I think it's nice, it's a post about a few of the features of Crystal so letâ€™s get straight down to it.&lt;/p&gt;&lt;h2&gt;&lt;code&gt;alias&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; is a very common feature that we can see across many languages but it can be used to build upon other features in Crystal. As the name suggests you use &lt;code&gt;alias&lt;/code&gt; to give a type a different name.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;TableOfContents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;Int32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the example above we give the type &lt;code&gt;Hash(String, Int32)&lt;/code&gt; a custom alias of &lt;code&gt;TableOfContents&lt;/code&gt; which allows us to refer to this type as &lt;code&gt;TableOfContents&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chapter&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tableOfContents&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;TableOfContents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;Int32&lt;/span&gt;
  &lt;span class="n"&gt;tableOfContents&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chapter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So instead of using &lt;code&gt;Hash(String, String)&lt;/code&gt; in the method signature above we can use &lt;code&gt;TableOfContents&lt;/code&gt;. So why is this useful? Well for one thing it allows us to reduce complex type names into smaller names. The example above isn't exactly verbose but longer types can be more readable.&lt;/p&gt;&lt;p&gt;Now of course size isn't everything so another advantage of &lt;code&gt;alias&lt;/code&gt; is that we can add meaning to types within our problem domain. You're less likely to wonder what this hash of string to string is or should contain when we give a name like &lt;code&gt;TableOfContents&lt;/code&gt;. In fact, we could enrich the signature above more by giving specific types an alias.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;ChapterTitle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;
&lt;span class="k"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;PageNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Int32&lt;/span&gt;
&lt;span class="k"&gt;alias&lt;/span&gt; &lt;span class="no"&gt;TableOfContents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Hash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;ChapterTitle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;PageNumber&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From this we can infer that for a given chapter title the table of contents is capable of finding the page number that the chapter starts on.&lt;/p&gt;&lt;h2&gt;&lt;code&gt;union&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Unlike many languages the return type of methods can actually be more than one type. Crystal uses type inference so declaring types is not mandatory. Take a look at this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;doAThing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isAThing&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isAThing&lt;/span&gt;
    &lt;span class="s2"&gt;"I did a thing"&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="mi"&gt;42&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What type is this? It could be an &lt;code&gt;Int32&lt;/code&gt; it could be a &lt;code&gt;String&lt;/code&gt;. In other statically typed languages the type most likely resolves to some common base class like &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;Any&lt;/code&gt; which makes sense but is actually a tiny bit pants&lt;a name="_1"&gt;&lt;/a&gt;&lt;a href="#1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;In Crystal this type will be inferred as &lt;code&gt;String|Int32&lt;/code&gt;. This is a union and is essentially a type of its own that could be either a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Int32&lt;/code&gt;. We can explicitly give this method a return type which means the compiler can verify our assumption&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;doAThing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isAThing&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;Bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="no"&gt;Bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You may have noticed I just wrote the wrong return type and attempting to compile the code results in a helpful compilation error message&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="bash"&gt;Error in ./src/something.cr:14: instantiating &lt;span class="s1"&gt;'doAThing(Bool)'&lt;/span&gt;

doAThing&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
^

in ./src/something.cr:6: &lt;span class="nb"&gt;type &lt;/span&gt;must be &lt;span class="o"&gt;(&lt;/span&gt;String | Bool&lt;span class="o"&gt;)&lt;/span&gt;, not &lt;span class="o"&gt;(&lt;/span&gt;String | Int32&lt;span class="o"&gt;)&lt;/span&gt;

def doAThing&lt;span class="o"&gt;(&lt;/span&gt;t : Bool&lt;span class="o"&gt;)&lt;/span&gt; : String|Bool
    ^
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Union types give us the rigidity and predictability of types while, at the same time, allowing a certain amount of flexibility as if we were working in a purely dynamic language. &lt;/p&gt;&lt;h2&gt;&lt;code&gt;case&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;So we've got these nice &lt;code&gt;union&lt;/code&gt; types how do we deal with them in code? Well similar to other languages Crystal has methods like &lt;code&gt;is_a?(type_name)&lt;/code&gt; and &lt;code&gt;responds_to?(method_name)&lt;/code&gt; that allows us to inspect the current type of the variable but it also supports a kind of pattern matching for types using &lt;code&gt;case&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="ruby"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;readFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="no"&gt;Error&lt;/span&gt;
  &lt;span class="c1"&gt;# read file return a string of its contents&lt;/span&gt;
&lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="n"&gt;an_error&lt;/span&gt;
  &lt;span class="n"&gt;an_error&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;maybeContents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;readFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"somefile.txt"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;maybeContents&lt;/span&gt;
&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;maybeContents&lt;/span&gt;
&lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="no"&gt;Error&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"We had a wee error doing that"&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In each &lt;code&gt;when&lt;/code&gt; of the &lt;code&gt;case&lt;/code&gt; the type of &lt;code&gt;maybeContents&lt;/code&gt; will be the specific type that was matched against. So &lt;code&gt;maybeContents&lt;/code&gt; will start as a &lt;code&gt;String|Error&lt;/code&gt; but be available as a &lt;code&gt;String&lt;/code&gt; in the first &lt;code&gt;when&lt;/code&gt; and an &lt;code&gt;Error&lt;/code&gt; in the second &lt;code&gt;when&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;&lt;p&gt;&lt;sup&gt;&lt;a name="1"&gt;&lt;/a&gt;&lt;a href="#_1"&gt;1&lt;/a&gt;: "pants" means bad.&lt;/sup&gt;&lt;/p&gt;</content></entry></feed>