<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:design</id><updated>Sat Nov 17 00:00:00 UTC 2012</updated><title type="text">Yo! Briefcase: design</title><link rel="self" href="https://yobriefca.se/feed/design.xml"></link><entry><title>Vertical vs Horizontal Thinking</title><updated>Sat Nov 17 00:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/11/17/vertical-vs-horizontal-thinking/"></link><id>urn:yobriefca-se:feed:post:Vertical vs Horizontal Thinking</id><content type="html">&lt;p&gt;I'm not quite sure were this ramble is going to lead, it's been a while since I've felt like writing something that hasn't been clearly defined by my half conscious brain but lets take the journey anyway shall we?&lt;/p&gt;&lt;p&gt;This is going to be loosely related to agility, not necessarily the "agile method or process" but more simply about adapting to change and embracing transparency in a software project. More often than not this can be simply referred to as "common sense" and it's a great thing. &lt;/p&gt;&lt;p&gt;But I digress,&lt;/p&gt;&lt;p&gt;In a vertical world you deliver features by implementing vertical spikes through each layer of the system architecture. It doesn't have to be right, but it does need to be good enough for now. Sure it may not deliver the best user experience or maybe there are more HTTP requests or database calls than necessary but it's useable. Its shippable. &lt;/p&gt;&lt;p&gt;In the horizontal world layers of the architecture are tackled by (possibly pseudo) specialists and delivered en masse. This is very typical of the Big Design Upfront, Plan Based, Waterfall approach to delivery but its visible in a lot of projects in various guises and it's rather natural to many people.&lt;/p&gt;&lt;p&gt;Now, on the surface, getting specialists to deliver what they know best and then smash them altogether actually sounds great. You know your DB person is going to produce a wonderful hyper-normalised schema for you, your UI/UX person will deliver a gorgeous mockup of the site and your middle layer app people will deliver the best truly ReSTful service layer known to man. But then you spend an insane amount of time (or many many little periods of time) doing the actual integration and making this vision a reality. The testing, the regressions, the edge cases the performance hits and sacrifices through integrating perfect works of horizontal art. Best case you get it done eventually, worst case someone else gets it done by layering hack upon hack at integration points just to get it working. &lt;/p&gt;&lt;p&gt;Now imagine your DB person gets eaten by a badger, or your UI person decides they've had enough and goes to live in a free-love commune and drink the spiked kool-aid? I've overly dramatised the &lt;a href="http://en.wikipedia.org/wiki/Bus_factor"&gt;Bus Factor&lt;/a&gt; here but the point is still made. You've lost siloed knowledge forever and you need to spend time building it up again, and time and quality slip.&lt;/p&gt;&lt;p&gt;Finally - projects that deliver horizontally are, more often than not, projects that have limited customer/stakeholder visibility. Sometimes even less for end-users. So delivering a mockup of the UI and a DB schema that can be exported as a nice UML diagram is enough to satisfy people that work is on-going and going well. Even if it isn't. It's not a lie but it is a false impression, and it's an impression that doesn't work for long especially if you have shorter release cycles with ongoing customer interaction. A page of beautiful buttons that don't do anything will create an impression that you are nearly done and can easily generate disappointment at subsequent demos. Is it worth it?&lt;/p&gt;&lt;p&gt;Don't get me wrong it is very possible to successfully deliver software in this manner, on time and on budget but so many things must fall into place and all the stars must be aligned that it's a rather big risk, but a risk that people seem to ignore.&lt;/p&gt;&lt;p&gt;So I'm saying vertical is better and there are many reasons for that and I'll touch on some of them here but there is one very fundamental reason it's better. Working and thinking vertically allows you to create a shippable product early. It's not all done, far from it. It probably looks like ass as well but still it's usable enough to get the job done, right? Imagine using a new product that looked amazing but only had 3 working features and the rest of the buttons and knobs didn't do anything. Wow factor is for kids and sales men.&lt;/p&gt;&lt;p&gt;Why else is vertical thinking better?&lt;/p&gt;&lt;p&gt;For one everyone on the team works across all layers of the solution. You don't have huge silos of knowledge contained in a single brain of some crazy bus magnet. Sure you may involve specialists to ensure you're not doing it totally wrong but at least you'd be working WITH them and picking up parts of the vast knowledge they may have.&lt;/p&gt;&lt;p&gt;By delivering something "good enough for now" you actually reduce waste. True you may re-write a few things to get it right but you haven't spent hours crafting perfection only to tear it apart. Even better the first iteration may make users realise - "Actually you know what? That super whizzy button thing - we don't need it". Waterfall attempts to "manage change" because change in waterfall is scary expensive. Embrace it early and often and it much less costly.&lt;/p&gt;&lt;p&gt;Finally, the solution evolves rather than being dragged into existence from a 189 page document of business rules and textual assumptions. This allows you to experiment and try things, throw them away or discover a better way of doing things. You can adapt the solution at anytime to suit the changing nature of the environment it lives in.&lt;/p&gt;&lt;p&gt;Vertical thinking is a proven pattern in many other aspects of the software world. TDD for example. Rather than writing reams of code and testing it manually later, you create a solution bit by bit and adapt it fearlessly as you go. UI designers never just bang out one design and leave it there. Smaller feedback loops are essential to flow and success and vertical thinking gives you this. Break the habit of wowing people and replace it with the habit of delivering - it's a better, longer lasting feeling of win.&lt;/p&gt;</content></entry><entry><title>Caveat Abstractor</title><updated>Thu Feb 09 00:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/02/09/caveat-abstractor/"></link><id>urn:yobriefca-se:feed:post:Caveat Abstractor</id><content type="html">&lt;p&gt;&lt;em&gt;Ramblings from 30,000ft. The word abstraction is starting to sound odd.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Every time you create an abstraction there is a very good chance you've introduced unnecessary complexity into a solution. It should never be done alone - it should be a team decision. The goal of an abstraction is to simplify but in its untamed natural form an abstraction will only add complexity.&lt;/p&gt;
&lt;!-- more --&gt;&lt;p&gt;As programmers it's easy to fall into the trap whereby we want the code that we write to be the last time anyone ever has to write that code again. We dream of creating reusable works of art that ever other developer will use and never be concerned with the low level implementation ever again.&lt;/p&gt;&lt;p&gt;This is wrong and impossible. An anti-pattern even!&lt;/p&gt;&lt;p&gt;It baffles me that anyone would create an abstraction that they didn't have a need for at the time. It's wasteful and degrades the readability, grokability and all those other good "ilities" we use. Of course I say this like i don't do it myself but I'd be lying to you and myself.&lt;/p&gt;&lt;p&gt;An abstraction, by definition, is an intentional hiding of implementation and knowledge but surely understanding of these things will lead to a higher chance of success in a project? The person that created the abstraction has that understanding but it's like they dont want anyone else to know how it works. They're ready to take that secret to their grave.&lt;/p&gt;&lt;p&gt;When you start to abstract you need to remind yourself you are building a specific solution and not a framework (unless you are of course). Abstractions should be done only within the scope of the project and you should have a strong case to back up its creation (make the decision a team effort). This may sound like overhead but if you find it difficult to justify the creation odds are the abstraction is unnecessary.&lt;/p&gt;&lt;p&gt;Abstractions should not be grand, they should be light and convey their intent clearly by other people (pair programming and peer review will help weed out any verbose abstractions).&lt;/p&gt;&lt;p&gt;If you are creating an abstraction for anything other than DRY, odds are youre probably creating it for YAGNI. You'll start considering irrelevant use cases and having to cater for insane edge cases. This will happen even if you are taking a strong test driven approach - you'll concern youself with the workings of the abstraction rather then the problem you are solving and begin creating endless "what if" tests to cater for all those "0.00000001% chance of happening" edge cases. When this happens youre going to end up in mediocrity. Mediocre abstractions attract more abstraction. Even in a shared codebase bad abstractions create a certain amount of implied ownership to the person that created it. Inevitably someone will come along and create an abstraction around your abstraction (even if they have access to the original source). This in turn will likely become YAMA (Yet Another Mediocre Abstraction) attracting yet more abstraction.... You can guess where I am going with that one... Its abstractions all the way down and everytime you abstract you've decreased system comphension and likely destroyed another future developers soul.&lt;/p&gt;&lt;p&gt;In the same way guns dont kill people, people do - Abstraction dont kill projects, developers do. You've only got yourself to blame (been there done that, will be again). A nice simple abstraction, at the right time (e.g. When needed) can be expressive and helpful but too often we put the abstraction before the need.&lt;/p&gt;&lt;p&gt;So consider abstractions as "guilty until proven innocent" not the other way around. Solve YOUR problem - not every other problem, not until you need to.&lt;/p&gt;</content></entry><entry><title>Enterprise Scale</title><updated>Thu Jan 26 00:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/01/26/enterprise-scale/"></link><id>urn:yobriefca-se:feed:post:Enterprise Scale</id><content type="html">&lt;p&gt;Enterprise. What a broken, misued term. Its meant to sound big, huge even. I guess many years ago it used to mean big, huge, big business serious work.&lt;/p&gt;&lt;p&gt;But when you think about it, its none of those things really, not any more. Even the biggest multi-nationals entire enterprise backbone throughput is probably a small fraction of Lady Gagas Twitter feed. Enterprise is just that - one enterprise. Social is global, its all of us at anytime and that is so much bigger than some old enterprise. So if you try and pimp out your CV by using the term enterprise - the only people who are probably going to care are the managers and execs that think their little boring legacy system is unique and special... Do you really want to be sold that sort of job? All bytes are equal, some are more equal than others - Pah! Some are more mired in unnecessary abstraction, contracts and unread, out-of-date doucmentation but they are still bytes.&lt;/p&gt;</content></entry><entry><title>PowerMockup â Wireframe Toolkit for PowerPoint</title><updated>Fri Apr 15 23:00:00 UTC 2011</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2011/04/15/powermockup-a-wireframe-toolkit-for-powerpoint/"></link><id>urn:yobriefca-se:feed:post:PowerMockup â Wireframe Toolkit for PowerPoint</id><content type="html">&lt;p&gt;&lt;/p&gt;&lt;p&gt;Link: &lt;a href="http://www.powermockup.com/"&gt;&lt;/a&gt;&lt;a href="http://www.powermockup.com/"&gt;http://www.powermockup.com/&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;Disclosure Time:  I approached the developer of this app offering to do a review in exchange for a review license.  This isn't the sort of thing I usually blog about (except internally, a few times, in the company I work for) but I'm all for supporting the people who deserve support and truth be told I would probably have written this blog post anyway (yep it'll be a positive one)&lt;/blockquote&gt;&lt;p&gt;Happy with that?  Good lets crack on.&lt;/p&gt;&lt;h2&gt;The Past&lt;/h2&gt;&lt;p&gt;I've written a fair number UI design documents over the last few years and for all of these I have used &lt;a href="http://balsamiq.com"&gt;Balsamiq&lt;/a&gt;.  The problem with that is our companies standard/approved wire-framing solution is Visio (with the &lt;a href="http://www.guuui.com/issues/02_07.php"&gt;GUUUI templates&lt;/a&gt;).  Why did I go against the grain? Well I am not a mad fan of Visio.  It's not exactly lightweight, in fact it's extremely bloated (at least in the wire-framing sense), and that is easily the worst thing you can ask for when dealing with highly iterative, dynamic, interactive wire-framing.  You need to work with the Visio rather than let Visio work for you and that is slightly too much fail for me most of the time.  Admittedly there has been times I prefer the slicker, more professional, output of Visio (our customers come from the stiff collar world of finance and the like so it tends to sit better with them).  But were I can I stick with Balsamiq.  Until now....&lt;/p&gt;&lt;h2&gt;The Present&lt;/h2&gt;&lt;p&gt;The problem I've always faced with Balsamiq is that when I produce a first draft of a document with, say, 20 odd wireframes in it and something fundamental is changed by the customer then I have a hard slog ahead to fix all those images.  Thankfully a colleague of mine, one much better at this wire-framing/UX stuff than me, pointed me towards PowerMockup.  Rather than make a new standalone application that has it's own random UI features and offers little to on integration into the app we use day today PowerMockup is simply an extension/add-on to Powerpoint.  So what does this mean?  Well it means,&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The devs spent more time into the templates and stuff that matter&lt;/li&gt;&lt;li&gt;Fully integrated into the Office application stack (think ability to tweak results when embedded into Word)&lt;/li&gt;&lt;li&gt;Already makes use of the built in “smart” styling and other features that make Powerpoint actually a fairly decent app for quick templating and stuff.  In fact take it a step further and you could make use of Powerpoint's animation stuff to demonstrate UI interactions.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So given 5 minutes what could I do?  And I do mean 5 minutes (possibly slightly less).  Well I mocked up the website you are reading right now. &lt;/p&gt;&lt;p class="img-holder"&gt;&lt;img src="http://farm4.static.flickr.com/3151/5720048084_8b4994da36_z.jpg" /&gt;&lt;/p&gt;&lt;p&gt;Trippy eh?  It's not my best work (far from it) but it did help me test drive PowerMockup and get a better feel of it.  So I like it.  I like it because of all the things I've mentioned above (who wouldn't).  I'd use it, and will use it, as my wire-framing tool of choice (and not because I got a free license - my work would pay for it anyway cause they are total aces) from now on but it's not perfect.  If I had to pick holes there are a few things that I'd mention,&lt;/p&gt;&lt;ul&gt;&lt;li&gt;My biggest peeve but it's not a show stopper is the location of the various shapes/widgets.  Dropdowns are in “Navigation” and Text fields are in “Text” but 99% of the time I'd want both of those when constructing a form.  I'd really like a “Form” collection with all of these things grouped.&lt;/li&gt;&lt;li&gt;If I drop a browser container on the page then drop a scrollbar on the page I need to resize said scrollbar to fit the browser container.  Problem is, as the scrollbar is a grouped object, it will stretch the entire thing rather than extend the base rectangle.  Again no show stopper but it is a bit of a pain.  I guess offering the components as separate shapes might make it easier (just a suggestion).&lt;/li&gt;&lt;li&gt;There a plenty of icons but I'd like to see a few more (“comments” icon, “tags” icon) - the equivalent famfamfam icon set would blow me away (and also a lot to ask).  Possibly some more mobile shapes etc. would also be nice.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;The Future&lt;/h2&gt;&lt;p&gt;So thats it for now I am very happy, not because I managed to blag a free license, but rather because the app/plugin/whatever fits into how I do things so seamlessly.  Good work and I look forward to future updates - hopefully more people think the same.&lt;/p&gt;</content></entry></feed>