<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:elm</id><updated>Sun Aug 02 00:00:00 UTC 2015</updated><title type="text">Yo! Briefcase: elm</title><link rel="self" href="https://yobriefca.se/feed/elm.xml"></link><entry><title>Deconstructing Your First Elm App</title><updated>Sun Aug 02 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/08/02/deconstructing-your-first-elm-app/"></link><id>urn:yobriefca-se:feed:post:Deconstructing Your First Elm App</id><content type="html">&lt;blockquote&gt;&lt;p&gt;This article is similar to the &lt;a href="https://github.com/evancz/elm-architecture-tutorial#the-elm-architecture"&gt;Elm Architecture Tutorial&lt;/a&gt; so if you fancy a more official explanation you should check that out too.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;One of things that has really impressed me in my research of &lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt; has been the simplicity of the architecture of an application. An Elm app is essentially just a reactive stream of actions that transition the model into various states and in turn these state changes cause the view to redraw. You don't mutate anything you just create a new state and the entire application redraws itself. Oh and it's fast too. This is thanks to the &lt;a href="http://elm-lang.org/blog/blazing-fast-html"&gt;virtual DOM&lt;/a&gt; approach that has risen to fame through the likes of Elm and &lt;a href="http://facebook.github.io/react/"&gt;React&lt;/a&gt;. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Essentially Elm allows you to treat the UI as an &lt;a href="http://iki.fi/sol/imgui/"&gt;Immediate Mode UI&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;h2&gt;Deconstruction&lt;/h2&gt;&lt;p&gt;What I want to do is demonstrate this simplicity by creating a very simple application firstly using the &lt;code&gt;start-app&lt;/code&gt; package and then without using the &lt;code&gt;start-app&lt;/code&gt; package. By using the &lt;code&gt;start-app&lt;/code&gt; package initially we can see how an Elm app hangs together at a high level then, by removing the use of the package, we can dive a bit deeper into how our application is made reactive with some really simple functional patterns.&lt;/p&gt;&lt;h2&gt;Using start-app&lt;/h2&gt;&lt;p&gt;The &lt;a href="https://github.com/evancz/start-app"&gt;start-app&lt;/a&gt; package abstracts away most of the boilerplate required to wire up a typical Elm application. It is designed to help people new to Elm get their first application up and running without to much upfront cognitive load. You just supply the &lt;code&gt;StartApp.start&lt;/code&gt; a type containing&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Your &lt;code&gt;model&lt;/code&gt; that is used to store state&lt;/li&gt;
  &lt;li&gt;Your &lt;code&gt;view&lt;/code&gt; that provides a visual representation of the current state, and,&lt;/li&gt;
  &lt;li&gt;Your &lt;code&gt;update&lt;/code&gt; method that, through action signals generated from inside or outside your application, transitions your model from one state to another&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;If you want to follow along you need to have Elm installed. Have a look at the &lt;a href="http://elm-lang.org/install"&gt;official site for instructions&lt;/a&gt; and various editor plugins for Elm.&lt;/p&gt;&lt;p&gt;So lets create our first application. &lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sh"&gt;&amp;gt; mkdir elm-demo-start-app &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd &lt;/span&gt;elm-demo-start-app

&amp;gt; elm package install

Some new packages are needed. Here is the upgrade plan.

  Install:
    elm-lang/core 2.1.0

Do you approve of this plan? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y
Downloading elm-lang/core
Packages configured successfully!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This gives us the necessary manifests and caches that you get with any package managers in Elms case we get,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;elm-package.json&lt;/code&gt; which declares all the metadata and dependencies our application needs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;elm-stuff/&lt;/code&gt; which acts as our package cache. You'll see the source of the dependencies we downloaded in the previous steps.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Then we want to add the extra dependencies that allow us to quickly build our Elm app,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sh"&gt;&amp;gt; mkdir elm-demo-start-app &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd &lt;/span&gt;elm-demo-start-app

&amp;gt; elm package install

Some new packages are needed. Here is the upgrade plan.

  Install:
    elm-lang/core 2.1.0

Do you approve of this plan? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y
Downloading elm-lang/core
Packages configured successfully!

&amp;gt; elm package install evancz/elm-html 3.0.0

To install evancz/elm-html I would like to add the following
dependency to elm-package.json:

    &lt;span class="s2"&gt;"evancz/elm-html"&lt;/span&gt;: &lt;span class="s2"&gt;"3.0.0 &amp;lt;= v &amp;lt; 4.0.0"&lt;/span&gt;

May I add that to elm-package.json &lt;span class="k"&gt;for &lt;/span&gt;you? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y

Some new packages are needed. Here is the upgrade plan.

  Install:
    evancz/elm-html 3.0.0
    evancz/virtual-dom 1.2.3

Do you approve of this plan? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y
Downloading evancz/elm-html
Downloading evancz/virtual-dom
Packages configured successfully!

&amp;gt; elm package install evancz/start-app 1.0.0

To install evancz/start-app I would like to add the following
dependency to elm-package.json:

    &lt;span class="s2"&gt;"evancz/start-app"&lt;/span&gt;: &lt;span class="s2"&gt;"1.0.0 &amp;lt;= v &amp;lt; 2.0.0"&lt;/span&gt;

May I add that to elm-package.json &lt;span class="k"&gt;for &lt;/span&gt;you? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y

Some new packages are needed. Here is the upgrade plan.

  Install:
    evancz/start-app 1.0.1

Do you approve of this plan? &lt;span class="o"&gt;(&lt;/span&gt;y/n&lt;span class="o"&gt;)&lt;/span&gt; y
Downloading evancz/start-app
Packages configured successfully!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So far, via the most polite package manager I've ever encountered, we have installed&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;evancz/elm-html&lt;/code&gt; which allows us to work and build HTML and associated elements attributes, events and CSS styling&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;evancz/virtual-dom&lt;/code&gt; is installed as dependency of &lt;code&gt;elm-html&lt;/code&gt; and provides the virtual DOM implementation that Elm uses.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;evancz/start-app&lt;/code&gt; a small library for making writing standard Elm apps with less upfront wiring.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;TO THE CODE!!&lt;/h2&gt;&lt;p&gt;The app is going to be really basic, and I really do mean basic. Just enough to demonstrate the core components of the Elm architecture - the &lt;strong&gt;model&lt;/strong&gt; for holding state, the &lt;strong&gt;view&lt;/strong&gt; for visualising app state and the &lt;strong&gt;update&lt;/strong&gt; function for transitioning our state.&lt;/p&gt;&lt;p&gt;&lt;img src="/images/blog/elm-demo.png" alt="App States" _="_" /&gt;&lt;/p&gt;&lt;p&gt;The app will have 2 buttons - "Mark" and "Reset". When you click "Mark" the app will append a &lt;strong&gt;block&lt;/strong&gt; (â–ˆ) character to represent that event to the event log and increment the number of events logged. When you click "Reset" the app will clear the event log and zero the number of events logged. Contrived? Yes of course. But acceptably so.&lt;/p&gt;&lt;h2&gt;Starting Point&lt;/h2&gt;&lt;p&gt;So lets create an &lt;code&gt;EventLog.elm&lt;/code&gt; file. This will be our one and only code file for the application. We'll start by declaring the module and importing the necessary packages,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;EventLog&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html&lt;/span&gt;            &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html.Events&lt;/span&gt;     &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html.Attributes&lt;/span&gt; &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Signal&lt;/span&gt;          &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;StartApp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I've just imported a lot more than we will need for this app but feel free to curate your imports a bit better if you so desire. &lt;/p&gt;&lt;p&gt;Now we will start from the bottom up and declare our &lt;code&gt;main&lt;/code&gt; function. This is the starting point for all Elm apps. It will usually return a &lt;code&gt;Signal&lt;/code&gt; of some type that can be used by the Elm infrastructure to perform the necessary (re)rendering of your application. You can think of a &lt;code&gt;Signal&lt;/code&gt; as a typed stream that emits items as and when they are generated. &lt;/p&gt;&lt;p&gt;As we are using the &lt;code&gt;start-app&lt;/code&gt; package ours will look like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="kt"&gt;StartApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;initialModel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have included the type signature in here for good measure. Our &lt;code&gt;main&lt;/code&gt; simply calls into &lt;code&gt;StartApp.start&lt;/code&gt; passing in our 3 main components. Of course we still need to define these so lets go ahead and do this.&lt;/p&gt;&lt;h2&gt;Model&lt;/h2&gt;&lt;p&gt;Our model will define the entire state of our application. In our case this won't be very big at all, in fact it could literally just be a counter the we increment but for the sake of this experiment we will make it slightly more verbose,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;initialModel&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;initialModel&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I defined a &lt;code&gt;type alias&lt;/code&gt; because it avoids the mess of having to declare the type as &lt;code&gt;{ events: List String }&lt;/code&gt; in every type signature that includes it. Then I defined our &lt;code&gt;initialModel&lt;/code&gt; using the &lt;code&gt;alias&lt;/code&gt;. The &lt;code&gt;initialModel&lt;/code&gt;, as the name suggests, is our starting state for our application. An empty model.&lt;/p&gt;&lt;h2&gt;View&lt;/h2&gt;&lt;p&gt;So now we have our state we can create a visual representation of that state by creating our &lt;code&gt;view&lt;/code&gt;,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;view&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Address&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;view&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="s"&gt;"?"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; 
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"Mark"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;Reset&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; 
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"Reset"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;h2&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; 
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;" Events"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; 
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I'd typically break this into smaller functions to keep it a bit cleaner but for explanation purposes this is good enough. Our view takes an &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt;. The &lt;code&gt;address&lt;/code&gt; is passed in from the work done by &lt;code&gt;start-app&lt;/code&gt; and provides a mailbox to send messages our actions to in order to update the model. The model in this case is the current state of the entire application.&lt;/p&gt;&lt;p&gt;With these key bits of data we construct a primitive HTML representation. &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We define buttons that have &lt;code&gt;onClick&lt;/code&gt; handlers. These handlers simply send actions (we define this type later) to the supplied address.&lt;/li&gt;
  &lt;li&gt;We define an &lt;code&gt;h2&lt;/code&gt; element that counts the number of events in our event list and displays it&lt;/li&gt;
  &lt;li&gt;Finally we define a &lt;code&gt;div&lt;/code&gt; that converts our events list into HTML elements&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Actions&lt;/h2&gt;&lt;p&gt;Lets go back to this &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;actions&lt;/code&gt;. As mentioned the &lt;code&gt;start-app&lt;/code&gt; package creates an internal mailbox and address that you can send things to which will get passed into our &lt;code&gt;view&lt;/code&gt; function. When we send stuff to the address this will ultimately trigger a call to the apps &lt;code&gt;update&lt;/code&gt; function. As you can see from the type signature of &lt;code&gt;view&lt;/code&gt; the &lt;code&gt;Address&lt;/code&gt; is of type &lt;code&gt;Address Action&lt;/code&gt;. &lt;code&gt;Action&lt;/code&gt; is a type that we will define so lets do that and talk about it after.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you think back to the UI we had 2 buttons - Mark and Reset. What the &lt;code&gt;Action&lt;/code&gt; type does is create a representation of these UI interactions that can be used within our app to signal intent. Types like the &lt;code&gt;Action&lt;/code&gt; type - the ones that use &lt;code&gt;|&lt;/code&gt; - are called union types. In some ways you can think of them as enums that can accept data as well. By defining this &lt;code&gt;Action&lt;/code&gt; type we explicitly declare all the actions that will change the state within our application. No just &lt;strong&gt;can&lt;/strong&gt; but &lt;strong&gt;must&lt;/strong&gt;. That's predictable, thats wonderful and lovely and makes me feel all warm inside.&lt;/p&gt;&lt;p&gt;So, yes sorry I got all excited, the buttons we defined in our &lt;code&gt;view&lt;/code&gt; method, each, sends one of these types to the supplied mailbox address. So lets define what happens when we do this,&lt;/p&gt;&lt;h2&gt;Update&lt;/h2&gt;&lt;p&gt;Right. We have a model, a view and a way to signal changes in state via actions. Now we need to actually manage those state changes. This is where the final piece of the puzzle falls into place,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;update&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;update&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;Reset&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;update&lt;/code&gt; function is just one big &lt;code&gt;case&lt;/code&gt; statement. It gets passed an action and the current state of our application and depending on the action we return a new state for our application. This generation of new state causes our application to be re-rendered and the glorious cycle begin again.&lt;/p&gt;&lt;p&gt;For completeness sake here is the entire &lt;code&gt;EventLog.elm&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;EventLog&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html&lt;/span&gt;            &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html.Events&lt;/span&gt;     &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html.Attributes&lt;/span&gt; &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Signal&lt;/span&gt;          &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;StartApp&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;initialModel&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;initialModel&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Reset&lt;/span&gt;

&lt;span class="nf"&gt;update&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;update&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;Reset&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;view&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Address&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;view&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Mark&lt;/span&gt; &lt;span class="s"&gt;"?"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"Mark"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;Reset&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"Reset"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;h2&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;" Events"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
      &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="kt"&gt;StartApp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;initialModel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Running the App&lt;/h2&gt;&lt;p&gt;Elm comes with some lovely tools to get your first app up and running without having to worry about the usually front end infrastructure such as grunt, gulp, bower, npm and so on and so forth. One of these is &lt;code&gt;reactor&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="sh"&gt;&amp;gt; elm reactor

Elm Reactor 0.3.2 &lt;span class="o"&gt;(&lt;/span&gt;Elm Platform 0.15.1&lt;span class="o"&gt;)&lt;/span&gt;
Listening on http://0.0.0.0:8000/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running &lt;code&gt;elm reactor&lt;/code&gt; starts up a little file server (typically on port 8000) and if you navigate to &lt;code&gt;http://localhost:8000&lt;/code&gt; you will see the project files listed. By clicking &lt;code&gt;EventLog.elm&lt;/code&gt; reactor will compile your Elm code to JavaScript and inject it into an ephemeral HTML document so you can see and play with our utterly useless creation.&lt;/p&gt;&lt;h2&gt;Wrapping Up start-app&lt;/h2&gt;&lt;p&gt;So in summary&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code&gt;main&lt;/code&gt; function starts our app using &lt;code&gt;StartApp.start&lt;/code&gt; which we pass our three main components&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;model&lt;/code&gt; represents the current state of our entire application&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;view&lt;/code&gt; provides a visual representation of our current application state and also generates action signals from user interaction that trigger an update in our application&lt;/li&gt;
  &lt;li&gt;The &lt;code&gt;update&lt;/code&gt; function takes these actions and creates a new state model for our application which triggers a re-rendering of our view&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;This is a deceptively simple approach that avoids one of the main pain points in application development - mutable state. Having to manage mutable state introduces a lot of complexity and unpredictability - two things that should never really mix.&lt;/p&gt;&lt;h2&gt;Removing start-app&lt;/h2&gt;&lt;p&gt;So the next question is "what does start-app do?". As I've demonstrated &lt;code&gt;start-app&lt;/code&gt; has provided the glue for realising our application - we just provided the components. Knowing how these things glue together really helps with understanding Elm and its additional features such as signals and ports.&lt;/p&gt;&lt;h2&gt;The Mailbox&lt;/h2&gt;&lt;p&gt;As we've seen in the previous implementation our view function gets passed an &lt;code&gt;address&lt;/code&gt; something that we didn't create ourselves. Internally &lt;code&gt;start-app&lt;/code&gt; creates a mailbox - a concept in Elm that provides a typed address that we can send messages to and a signal that emits a value when the address receives a message. So you can see that when we send an action message to the address via the &lt;code&gt;onClick&lt;/code&gt; handler in our view we can then trigger a state update.&lt;/p&gt;&lt;p&gt;Without the &lt;code&gt;start-app&lt;/code&gt; we need to create the mailbox ourselves,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;actions&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Mailbox&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt;
&lt;span class="nf"&gt;actions&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;mailbox&lt;/span&gt; &lt;span class="kt"&gt;Reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our &lt;code&gt;actions&lt;/code&gt; mailbox has a type of &lt;code&gt;Action&lt;/code&gt; and when we create our mailbox we supply it an example of our &lt;code&gt;Action&lt;/code&gt; type (in this case &lt;code&gt;Reset&lt;/code&gt;). Often you'll see action types defined with a &lt;code&gt;NoOp&lt;/code&gt; and that is often used as an example. Either way he have our mailbox.&lt;/p&gt;&lt;h2&gt;Reactive Model&lt;/h2&gt;&lt;p&gt;Next up we need to take our initial state and turn it into a reactive model. So that when an action message is received it will cause the &lt;code&gt;update&lt;/code&gt; method to alter our state. Now this part is, IMHO, just the cleverest little pattern. The reactive model is just a fold over the signal that is a property of our mailbox starting with our initialState&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;model&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;foldp&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="n"&gt;initialModel&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK technically it's a &lt;code&gt;foldp&lt;/code&gt; which is a special signal variant of &lt;code&gt;fold&lt;/code&gt; that can yield intermediate results (as an when actions are generated). But thats it. Starting with our initial data when actions occur call the update method - the result of which is yielded by &lt;code&gt;foldp&lt;/code&gt;. We have our reactive model.&lt;/p&gt;&lt;h2&gt;Mapping Main&lt;/h2&gt;&lt;p&gt;Finally we need to replace our &lt;code&gt;main&lt;/code&gt; method and wire up all these parts to create our working application. &lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now &lt;code&gt;main&lt;/code&gt; becomes a &lt;code&gt;map&lt;/code&gt; over the view using our &lt;code&gt;model&lt;/code&gt; (the one we made reactive in the last step). As &lt;code&gt;view&lt;/code&gt; takes both an &lt;code&gt;address&lt;/code&gt; and a &lt;code&gt;model&lt;/code&gt; so we create a partially applied or curried function of &lt;code&gt;(view actions.address)&lt;/code&gt; that takes the address from our mailbox. So when the model updates the &lt;code&gt;map&lt;/code&gt; will cause the view function to be called with the new state which will build our HTML representation and yield a signal value with that HTML representation into the core of Elms rendering engine. Once again the &lt;code&gt;map&lt;/code&gt; function (from the &lt;code&gt;Signal&lt;/code&gt; package) yields intermediate responses.&lt;/p&gt;&lt;h2&gt;And rest...&lt;/h2&gt;&lt;p&gt;So that covers the basic architecture of a typical Elm application. You can see how &lt;code&gt;start-app&lt;/code&gt; removes some of the extra steps required to wire up an Elm application and would certainly lower the barrier of entry for people new to Elm. That said there are times you want access to the Mailbox (such as when trying to merge in external signals from &lt;code&gt;ports&lt;/code&gt;) and &lt;code&gt;start-app&lt;/code&gt; hides the mailbox it creates on your behalf.&lt;/p&gt;&lt;p&gt;The underlying principles of Elm are surprisingly simple yet very powerful. They aren't niche concepts either. Fundamentally they are common functional patterns which means, with a modicum of functional thinking, that application design is less made complex as we have to incur less cost in understanding concepts specific to Elm.&lt;/p&gt;</content></entry><entry><title>Zombie Dice Score Card in Elm</title><updated>Wed Jul 29 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/07/29/zombie-dice-score-card-in-elm/"></link><id>urn:yobriefca-se:feed:post:Zombie Dice Score Card in Elm</id><content type="html">&lt;p&gt;&lt;a href="https://yobriefca.se/blog/2015/07/28/window-dot-prompt-in-elm/"&gt;As promised&lt;/a&gt; yesterday evening I spent some time re-writing my &lt;a href="https://yobriefca.se/blog/2015/07/20/zombie-dice-score-card-with-reagent/"&gt;Zombie Dice Score Card&lt;/a&gt;, originally written in ClojureScript and &lt;a href="http://reagent-project.github.io/"&gt;Reagent&lt;/a&gt;, in &lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;If you just want to poke around the code then the source for each implementation is available on Github,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/kouphax/zombie-dice-elm"&gt;The Elm implementation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/kouphax/zombie-dice"&gt;The ClojureScript implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;If you want a bit of an experience report then read on.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;This work was done after spending an evening with some &lt;a href="https://pragmaticstudio.com/elm"&gt;Elm screencasts&lt;/a&gt; and some internet research I cannot promise this is &lt;strong&gt;good&lt;/strong&gt; or &lt;strong&gt;correct&lt;/strong&gt; code and I'll welcome any &lt;a href="https://twitter.com/kouphax"&gt;feedback via Twitter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Developing the Elm version of the app took the best part of 3 or 4 hours once I discovered how to &lt;a href="https://yobriefca.se/blog/2015/07/28/window-dot-prompt-in-elm/"&gt;integrate with JavaScript via ports&lt;/a&gt;. All in all I'd say there is about 6 or 7 hours work to craft my first Elm app with only a couple of hours introduction to the language. This should be seen as a positive reflection on &lt;strong&gt;Elm&lt;/strong&gt; and not me. &lt;/p&gt;&lt;h2&gt;Types&lt;/h2&gt;&lt;p&gt;My previous experience with type focused languages was a few years of general purpose Scala development and a brief foray into Haskell which ended in mild frustration. I'm certainly more comfortable in dynamic languages and if I was ever bored enough to be drawn into a "dynamic vs static" debate I'd probably side on the dynamic side. With that said picking apart my ClojureScript implementation and recreating it in Elm has really made me appreciate its typed nature. The ability to look at our defined types e.g.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;Player&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;       &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt;     &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;gamesWon&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;score&lt;/span&gt;    &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="n"&gt;alias&lt;/span&gt; &lt;span class="kt"&gt;ScoreBoard&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;players&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="kt"&gt;Player&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;uid&lt;/span&gt;     &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This explicit declaration really calls out stuff that, in ClojureScript (or &lt;strong&gt;my&lt;/strong&gt; ClojureScript code at least), is implied and typically scattered over the place. For example, in the code below I'm just pulling out keys from a map &lt;code&gt;:id&lt;/code&gt;, &lt;code&gt;:games-won&lt;/code&gt; etc. because &lt;strong&gt;I know&lt;/strong&gt; these things should exist. &lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn- &lt;/span&gt;&lt;span class="nv"&gt;finish-game&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;players&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vals &lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nv"&gt;scoreboard&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="nv"&gt;winner&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reduce &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:score&lt;/span&gt; &lt;span class="nv"&gt;%1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:score&lt;/span&gt; &lt;span class="nv"&gt;%2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;%1&lt;/span&gt; &lt;span class="nv"&gt;%2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;players&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;swap!&lt;/span&gt; &lt;span class="nv"&gt;scoreboard&lt;/span&gt; &lt;span class="nv"&gt;update-in&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="nv"&gt;winner&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;:games-won&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nv"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reset-scores&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Last night when I revisited this code I had forgotten what my model looked like and I had to figure it out by scanning all my code for when things are set and read from my data structure representing my state. I'm sure I could structure my ClojureScript better, perhaps use something like &lt;a href="https://github.com/clojure/core.typed"&gt;core.typed&lt;/a&gt; or &lt;a href="https://github.com/Prismatic/schema"&gt;Prismatic Schema&lt;/a&gt;, but the onus is on the developer. Of course this is not a new and startling revelation this is just one of the many difference in dynamic/static languages. So what does Elm do to make this different? Well, for one, it uses gradual typing. I can declare a function like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;newPlayer&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;       &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt;     &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;gamesWon&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;score&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will work fine and the Elm compiler will infer the types and shout at me if I'm passing ambiguous types around. However I can solidify my intentions by adding a type signature for the function,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;newPlayer&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Player&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I initially started dipping into Elm I thought these signatures would be an after thought for me. I'd only add them in for completeness sake. I was wrong. They are extremely useful and helped massively as I designed my implementation. They also improve the error messages. Scala has this sort of type inference as well but I almost always left it out unless required. Perhaps I've got wiser in my old age or maybe Elm has made the type system more accessible.&lt;/p&gt;&lt;h2&gt;Error Messages&lt;/h2&gt;&lt;p&gt;When something goes wrong in Clojure or ClojureScript the resulting stacktraces can be next to useless for figuring out what is actually wrong. No amount of formatting and colouring improves this, sometimes they are just confusing. Error messages in Elm are the complete opposite.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;-- TYPE MISMATCH  ZombieDice.elm

The type annotation for `playerEntry` does not match its definition.

98| playerEntry: Address Action -&amp;gt; Player -&amp;gt; Html
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Looks like a record is missing the field `uid`

As I infer the type of values flowing through your program, I see a conflict
between these two types:

    Player

    { a | score : Int, uid : Int, gamesWon : Int, name : String } Use --force to continue.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just look at that message. It's telling me exactly what is wrong and I knew how to fix it once I'd read this message. Most Elm messages are like this although some of the type related ones did make me scratch my head until I wrapped my head around them a bit more.&lt;/p&gt;&lt;h2&gt;HTML&lt;/h2&gt;&lt;p&gt;Hiccup style syntax in ClojureScript that we use for describing HTML structure is lovely.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="clojure"&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:div.row&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:div.col.span_3.name&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:h2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:name&lt;/span&gt; &lt;span class="nv"&gt;player&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;for &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;win&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:games-won&lt;/span&gt; &lt;span class="nv"&gt;player&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:img&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:src&lt;/span&gt; &lt;span class="s"&gt;"images/gold-brain.png"&lt;/span&gt; &lt;span class="ss"&gt;:height&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;}])&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:div.col.span_3&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:image.brain&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="ss"&gt;:src&lt;/span&gt; &lt;span class="s"&gt;"images/brain.png"&lt;/span&gt;
                   &lt;span class="ss"&gt;:on-click&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;update-score&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:id&lt;/span&gt; &lt;span class="nv"&gt;player&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;}]&lt;/span&gt;
   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:span.score&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:small&lt;/span&gt; &lt;span class="s"&gt;" x "&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:score&lt;/span&gt; &lt;span class="nv"&gt;player&lt;/span&gt;&lt;span class="p"&gt;)]]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With paredit enabled creating this sort of structure is an absolute breeze and rather easy to comprehend after it's been written. The same, i'm afraid, can not be said for Elm,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;  &lt;span class="n"&gt;div&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="s"&gt;"row"&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;div&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="s"&gt;"col span_3 name"&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;h2&lt;/span&gt;
            &lt;span class="kt"&gt;[]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;player&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
          &lt;span class="n"&gt;span&lt;/span&gt;
            &lt;span class="kt"&gt;[]&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="n"&gt;wonGame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;player&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gamesWon&lt;/span&gt;&lt;span class="p"&gt;)])],&lt;/span&gt;
      &lt;span class="n"&gt;div&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="s"&gt;"col span_3"&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="s"&gt;"brain"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="n"&gt;src&lt;/span&gt;   &lt;span class="s"&gt;"images/brain.png"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Inc&lt;/span&gt; &lt;span class="n"&gt;player&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="kt"&gt;[]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;span&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="s"&gt;"score"&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;small&lt;/span&gt;
                &lt;span class="kt"&gt;[]&lt;/span&gt;
                &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt;
              &lt;span class="n"&gt;span&lt;/span&gt;
                &lt;span class="kt"&gt;[]&lt;/span&gt;
                &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="n"&gt;player&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;  &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is formatted, I think, using the recommended formatting advice and while it is relatively easy to read and get to the place you want to make changes it caused me a lot pain creating it and refactoring it as I added new features. I almost always misjudged bracket placement and forgot commas resulting in errors. Perhaps it's the fact paredit gives me so much power and ClojureScript doesn't use commas (they're treated as whitespace) but this was painful for me to create.&lt;/p&gt;&lt;h2&gt;It's just one big fold&lt;/h2&gt;&lt;p&gt;The architecture of an Elm app is always the same and it's really rather clever. However there is a bit of initial setup to get everything working. To this end you can use the &lt;a href="https://github.com/evancz/start-app"&gt;start-app package&lt;/a&gt; that removes a lot of the initial boilerplate (there's not really &lt;strong&gt;that much&lt;/strong&gt; boilerplate in reality). I didn't use this package as I wanted to really understand how everything was wired together.&lt;/p&gt;&lt;p&gt;This led to my big revelation. The root of an Elm app is just a map our reactive model that returns the updated view as and when our state changes. The reactive model part is just a fold over the application data which gets updated actions/signals happen that cause the state to transition to another state. &lt;/p&gt;&lt;p&gt;The entire app updates when something changes the state. &lt;/p&gt;&lt;p&gt;No management of discrete little parts and internal state - just rebuild the world. This is the same principle behind React and Reagent (a ClojureScript React wrapper) but in React the mechanisms are somewhat hidden. In Elm it's right there. You can compose different signals, Ã  la Reactive Extensions Observables, to make your app behave in different ways. For example,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;model&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Model&lt;/span&gt;
&lt;span class="nf"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt;
    &lt;span class="n"&gt;allActions&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mergeMany&lt;/span&gt;
      &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;externalActions&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="kr"&gt;in&lt;/span&gt;
    &lt;span class="n"&gt;foldp&lt;/span&gt; &lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="n"&gt;initialModel&lt;/span&gt; &lt;span class="n"&gt;allActions&lt;/span&gt;
    
&lt;span class="nf"&gt;externalActions&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt;
&lt;span class="nf"&gt;externalActions&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;mergeMany&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;~&lt;/span&gt; &lt;span class="n"&gt;addPlayer&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example from the app I merge the actions signal that comes from the apps main Mailbox (this is the one that streams all the internal Actions to update the model) and external signals (these are the ones that are generated by JavaScript outside of the Elm app). &lt;code&gt;externalActions&lt;/code&gt; does some manipulation of it's incoming data to create a signal of type &lt;code&gt;Action&lt;/code&gt; that can be merged with our core Action signal.&lt;/p&gt;&lt;p&gt;While I have likely explained this in the worst possible way this approach makes everything wonderfully composable and straightforward. As soon I saw how Elm approached reactive application development I was just blown away by its simplicity.&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I like Elm. Go try it. I can't really say one implementation of my little app is better than the other each has it's good and bad points. Besides I haven't spent enough time with Elm to evaluate it properly yet. All I know is that I've taken to it better than other languages of its ilk.&lt;/p&gt;&lt;p&gt;I'm not sure why it's type system feels more accessible to me compared to Scala or Haskell but I've found that the barrier of entry for Elm is much less than either of those languages. There seems to be, compared to Scala at least, much less concepts to wrap your brain around while still remaining extremely powerful. &lt;/p&gt;&lt;p&gt;Finally I recommend you check out &lt;a href="https://www.youtube.com/watch?v=oYk8CKH7OhE"&gt;this talk&lt;/a&gt; by Evan Czaplicki (creator of Elm) around the design decisions that help make Elm more accessible.&lt;/p&gt;</content></entry><entry><title>window.prompt() in Elm</title><updated>Tue Jul 28 00:00:00 UTC 2015</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2015/07/28/window-dot-prompt-in-elm/"></link><id>urn:yobriefca-se:feed:post:window.prompt() in Elm</id><content type="html">&lt;blockquote&gt;&lt;p&gt;I say "standard stuff" a few times in this article. When I say that I assume, like me, you've dipped your toes into Elm. If that is not the case and you want to change that situation then I recommend go give &lt;a href="https://pragmaticstudio.com/elm"&gt;Pragmatic Studios&lt;/a&gt; your money. I was in no way paid or influenced to say that BTW.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Having spent last night watching the Pragmatic Studios &lt;a href="https://pragmaticstudio.com/elm"&gt;Elm: Building Reactive Web Apps&lt;/a&gt; I am now a fully certified expert in &lt;a href="http://elm-lang.org"&gt;Elm&lt;/a&gt; and so it's time to start writing articles about it. Of course this is nonsense but some of my adventures have inspired me to write an article or two that may be useful to others (and my future self).&lt;/p&gt;&lt;p&gt;I &lt;a href="https://yobriefca.se/blog/2015/07/20/zombie-dice-score-card-with-reagent/"&gt;recently documented&lt;/a&gt; a little hobby project I worked on for keeping score on games of Zombie Dice. The app was written in ClojureScript and after I had wrapped my head around Elm I decided to see what the same app would look like in Elm. This article &lt;strong&gt;isn't&lt;/strong&gt; about that, but rather a small part of it that I found quite challenging.&lt;/p&gt;&lt;p&gt;Unlike ClojureScript (and Clojure) whose philosophy is to embrace the underlying host environment Elm abstracts it away. It's not gone completely it's just not as prevalent or easy to access. In my &lt;a href="https://yobriefca.se/zombie-dice/"&gt;Zombie Dice Score Card&lt;/a&gt; app adding new players uses the standard JavaScript host function &lt;code&gt;window.prompt&lt;/code&gt; to capture the name and I wanted to replicate this functionality in my Elm implementation.&lt;/p&gt;&lt;h2&gt;Basic Implementation&lt;/h2&gt;&lt;p&gt;My first pass at this resulted in a working implementation (well not my &lt;strong&gt;actual&lt;/strong&gt; first pass it was many, &lt;strong&gt;many&lt;/strong&gt; passes before I even figured out what the hell I was doing). While it wasn't going to be practical for my actual needs it did form the basis of something useful that I could build upon.&lt;/p&gt;&lt;p&gt;The key is to using &lt;code&gt;port&lt;/code&gt;s. A &lt;a href="http://elm-lang.org/guide/interop#ports"&gt;port&lt;/a&gt; acts as a bridge between Elm and JavaScript. They either go &lt;code&gt;in&lt;/code&gt; to Elm or &lt;code&gt;out&lt;/code&gt; of Elm. You declare a &lt;code&gt;port&lt;/code&gt; in Elm like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;suppliedNames&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is &lt;code&gt;port&lt;/code&gt; is an innie. You can tell it is an innie because you supply no actual definition. Instead we can &lt;code&gt;send&lt;/code&gt; things to it from the JavaScript side.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="javascript"&gt;&lt;span class="nx"&gt;app&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;suppliedNames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"James"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assuming, in our HTML file, our Elm app is created and assigned to a variable &lt;code&gt;app&lt;/code&gt; we will have this &lt;code&gt;ports&lt;/code&gt; object that lists all the ports we expose from our app. This will have our &lt;code&gt;suppliedNames&lt;/code&gt; port which will have a method of &lt;code&gt;send&lt;/code&gt; that we can use to signal values through that port.&lt;/p&gt;&lt;p&gt;One other thing is that these innies must be given an initial value when the app is constructed or you'll get an exception. We can do it like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="javascript"&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Elm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fullscreen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Elm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Confirm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;suppliedNames&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So when we boot our app we pass in an initial value.&lt;/p&gt;&lt;p&gt;Lets look at another port,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;totalCapacity&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;totalCapacity&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="n"&gt;somethingElse&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This one is an outtie. This is used to signal things &lt;strong&gt;out&lt;/strong&gt; of our Elm app into JavaScript. In this case it sends out the sum of some data structure as and when it changes. We can listen to these signals in JavaScript like this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="javascript"&gt;&lt;span class="nx"&gt;app&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;totalCapacity&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
  &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Outtie ports have a &lt;code&gt;subscribe&lt;/code&gt; method generated for them that takes a function accepting the payload. In our case we simply log it.&lt;/p&gt;&lt;p&gt;Now onto our specific use case. My needs are slightly different to the samples because while they broadcast data out of the Elm side I just want some sort of trigger to say "go ahead and open a prompt". This is 100% impure in that it is &lt;strong&gt;only&lt;/strong&gt; used for side effects and I've found that with Elm being a rather pure language this sort of requirement feels kind of awkward. Thats not a criticism, just an observation. You should expect bad things to feel awkward, it helps you minimise them.&lt;/p&gt;&lt;p&gt;The JavaScript/HTML side of our application is fairly unsurprising (assuming you've not skipped the last few paragraphs).&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="html"&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;charset=&lt;/span&gt;&lt;span class="s"&gt;"UTF-8"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  	  &lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text/javascript"&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"confirm.js"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text/javascript"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Elm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fullscreen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Elm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Confirm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;suppliedNames&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
    &lt;span class="nx"&gt;app&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prompt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prompt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Players name?"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;app&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;suppliedNames&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we, &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;boot our app passing in a blank value for &lt;code&gt;suppliedNames&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;subscribe&lt;/code&gt; to a &lt;code&gt;prompt&lt;/code&gt; port which will display the &lt;code&gt;window.prompt&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;send&lt;/code&gt; the captured value from &lt;code&gt;window.prompt&lt;/code&gt; back into our app&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The Elm side of things is where the real stuff happens,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Confirm&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;

&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html&lt;/span&gt;        &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Html.Events&lt;/span&gt; &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Signal&lt;/span&gt;      &lt;span class="n"&gt;exposing&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;..&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;-- SIGNALS &lt;/span&gt;
&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt;

&lt;span class="nf"&gt;actions&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Mailbox&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt;
&lt;span class="nf"&gt;actions&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mailbox&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt;

&lt;span class="c1"&gt;-- PORTS --&lt;/span&gt;
&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;suppliedNames&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;

&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;confirm&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;confirm&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;
    &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt;
    &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;-- VIEWS --&lt;/span&gt;
&lt;span class="nf"&gt;view&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;div&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="s"&gt;"Set Name"&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;

&lt;span class="c1"&gt;-- APP -&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;Html&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="n"&gt;suppliedNames&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given there is a fair few things happening here lets have a look at the interesting bits.&lt;/p&gt;&lt;p&gt;First of all we set up the various operations our application will perform and create a &lt;code&gt;Mailbox&lt;/code&gt; that can be used to send actions to. If you've ever tinkered with Elm this should be pretty common,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt;

&lt;span class="nf"&gt;actions&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Mailbox&lt;/span&gt; &lt;span class="kt"&gt;Action&lt;/span&gt;
&lt;span class="nf"&gt;actions&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
    &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mailbox&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;Prompt&lt;/code&gt; action is the one we want to use to trigger our &lt;code&gt;window.prompt&lt;/code&gt; call via a port. Next we declare our actual ports,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;suppliedNames&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;

&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;prompt&lt;/span&gt; &lt;span class="kt"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;port&lt;/span&gt; &lt;span class="n"&gt;prompt&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;
    &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;filter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;NoOp&lt;/span&gt;
    &lt;span class="o"&gt;|&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;suppliedNames&lt;/code&gt; is our innie. This will receive names we've created later on. &lt;code&gt;prompt&lt;/code&gt; is our outtie. What we do is &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;take the signal from our &lt;code&gt;Mailbox&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;filter&lt;/code&gt; everything except the &lt;code&gt;Prompt&lt;/code&gt; actions&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;map&lt;/code&gt; these values an &lt;code&gt;always&lt;/code&gt; return a &lt;code&gt;unit&lt;/code&gt; value&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Why &lt;code&gt;unit&lt;/code&gt;? Well we don't care about the actual value we just want to reach out to the JavaScript when we get a &lt;code&gt;Prompt&lt;/code&gt; action through our mailbox. Any value is meaningless so lets just go for the &lt;strong&gt;most meaningless&lt;/strong&gt; one we can find.&lt;/p&gt;&lt;p&gt;Then in our &lt;code&gt;view&lt;/code&gt; we have a &lt;code&gt;button&lt;/code&gt; that sends a &lt;code&gt;Prompt&lt;/code&gt; action to our Mailbox,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;button&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;onClick&lt;/span&gt; &lt;span class="n"&gt;actions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="kt"&gt;Prompt&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again this should be fairly unsurprising to the Elm-ites (or whatever the collective term is) reading this.&lt;/p&gt;&lt;p&gt;Finally we have our &lt;code&gt;main&lt;/code&gt; that wires it all together,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="haskell"&gt;&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="n"&gt;suppliedNames&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again - standard stuff.&lt;/p&gt;&lt;h2&gt;Notes&lt;/h2&gt;&lt;p&gt;As the last title indicated this is just a basic implementation. It requires a bit more work to integrate into an application that requires a more complicated model but its a good starting point. I know this because I've already begun extending it to create the Elm version of my &lt;a href="https://yobriefca.se/zombie-dice/"&gt;Zombie Dice Score Card&lt;/a&gt; which I'll dissect in another article soon.&lt;/p&gt;&lt;p&gt;Now I'm not saying this is idiomatic Elm, I'm not even saying this is a &lt;strong&gt;recommended&lt;/strong&gt; way to do things but it works and "feels" good enough to me. If you want to comment/fix/critique/whatever my work then you can get me on &lt;a href="https://twitter.com/kouphax"&gt;Twitter&lt;/a&gt; and let fly the dogs of conversation.&lt;/p&gt;</content></entry></feed>