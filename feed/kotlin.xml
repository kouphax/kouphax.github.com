<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><id>urn:yobriefca-se:feed:kotlin</id><updated>Wed Feb 24 00:00:00 UTC 2016</updated><title type="text">Yo! Briefcase: kotlin</title><link rel="self" href="https://yobriefca.se/feed/kotlin.xml"></link><entry><title>Kotlin - 2 Years On</title><updated>Wed Feb 24 00:00:00 UTC 2016</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2016/02/24/kotlin-2-years-on/"></link><id>urn:yobriefca-se:feed:post:Kotlin - 2 Years On</id><content type="html">&lt;p&gt;I &lt;a href="https://yobriefca.se/blog/2012/07/14/kotlin-heres-what-i-think-for-now/"&gt;first played&lt;/a&gt; with Kotlin back in 2012, I've written some Android apps with and without it and generally played around with it. Since the &lt;a href="http://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/"&gt;release of Kotlin 1.0&lt;/a&gt; a few days ago I've decided to jump back into it and see if my original views still hold up. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Herein lies opinion of the personal kind. Proceed with an open mind.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Scala is my day job, not only Scala but &lt;strong&gt;legacy/old&lt;/strong&gt; Scala. Not only that but &lt;strong&gt;a lot&lt;/strong&gt; of legacy/old Scala. Worse still not only a lot of legacy/old Scala but a lot of &lt;strong&gt;other peoples&lt;/strong&gt; legacy/old Scala. Thanks to the feature rich and impressively flexible nature of Scala this means there is a lot of sharp edges, unpredictability and a fresh arduous learning curve for each functional area. It can seem like a language designed by &lt;a href="https://en.wikipedia.org/wiki/At%C3%AB"&gt;AtÃ«&lt;/a&gt; at times.&lt;/p&gt;&lt;p&gt;Java is no better of course, it just resides at the other end of a spectrum, with its anaemic yet rigid feature set and almost pointless type system it's no wonder you see so many over-engineered and baklava-class layered solutions. Yeah Java 8 has improved the language a fair bit but the sacrifices made for backwards compatibility has meant those changes don't often go far enough.&lt;/p&gt;&lt;p&gt;Both Scala and Java require a lot of work to simplify so there has to be a middle ground and I (still) think that middle ground is Kotlin.&lt;/p&gt;&lt;p&gt;Think of Kotlin as C# for the JVM, Scala the Good Parts, Java++ or simply a decent general purpose language that won't require the blood of your first born. It's created by Jetbrains, it's about 5ish years old and just gone version 1.0. It is used extensively on Jetbrains products, being hailed as "Swift for Android" and works seamlessly within a mixed code base. It offers features similar to C# Extension methods, Scala implicits, Scala case classes, multiple inheritance and solid collection functionality like LINQ. It doesn't just ape Scala and C# features but introduces relatively original concepts like &lt;a href="http://kotlinlang.org/docs/reference/delegated-properties.html"&gt;delegated properties&lt;/a&gt;, &lt;a href="https://kotlinlang.org/docs/reference/delegation.html#class-delegation"&gt;class delegation&lt;/a&gt; and &lt;a href="https://kotlinlang.org/docs/reference/typecasts.html"&gt;typecasting&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;I'd also proffer that it has an easier transition from Java to Kotlin than it is for Scala though I have no evidence for this other than my own experience of all 3 languages (including leading mixed skill teams in Scala and Java).&lt;/p&gt;&lt;p&gt;You could ask "but why not one of the other many languages available on the JVM?" and that would be fair. Many JVM languages haven't seen a great deal of traction or remain relatively niche but I think Kotlin is much better placed. It's more "general purpose" than a lot of the alt languages which means it will map better to current practises. It's closer to Java and/or Scala than other languages, it strikes the right balance around the type system with features like type inference and enhanced generics and it doesn't hurt that Jetbrains; a major player in the JVM world; is heavily invested in Kotlins future.&lt;/p&gt;&lt;p&gt;In the two years since I started playing with Kotlin it has aged well. It resisted adding a plethora of features for the sake of it and instead created a core syntax and feature set that allows developers enough wiggle room for being creative without turning them into Wizards of Arcane DSLs. This is a sweet spot for me when it comes to building and supporting a service over many years as it avoids the unnecessary pain that comes from the extreme ends of spectrum that Java and Scala tend to reside. Of course this doesn't mean it's perfect, nothing is. You're still adding another language to a project and taking on the associated baggage that comes with it like tooling differences and additional upskilling. Its not suddenly going to make your organisation move the JVM if they aren't already there. It's also not going to fix all your problems - bad architecture will remain bad architecture and bad patterns will remain bad patterns. However, with that said, &lt;strong&gt;I believe Kotlin will reduce enough of the friction of general software development and maintenance on the JVM to make it worth the investment&lt;/strong&gt;.&lt;/p&gt;</content></entry><entry><title>expect.kt - Testing Library for Kotlin</title><updated>Tue Jul 24 23:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/07/24/expect-dot-kt-testing-library-for-kotlin/"></link><id>urn:yobriefca-se:feed:post:expect.kt - Testing Library for Kotlin</id><content type="html">&lt;p&gt;In a bid to delve into the &lt;a href="http://kotlin.jetbrains.org/"&gt;language&lt;/a&gt; a bit further than a rake of tiny console apps I decided to do something "real" with Kotlin. With that in mind - welcome &lt;a href="https://github.com/kouphax/expect.kt"&gt;expect.kt&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;It started purely as a learning venture but I think there is a certain usefulness in the library so its probably worth sharing :). Now it's worth noting that kotlin already has a number of testing statements that you can achieve a lot of this stuff with - this library gives you a few things over and above these statements &lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Alternative syntax. Testing is quite a personal thing and some people like to write things in different ways.&lt;/li&gt;
  &lt;li&gt;Descriptive assertions. Some would say &lt;code&gt;expect(2).toBePositive()&lt;/code&gt; reads better than &lt;code&gt;assertTrue(2 &amp;gt; 0)&lt;/code&gt; or &lt;code&gt;expect(2 &amp;gt; 0) { true }&lt;/code&gt;. Again its all about taste, and variety is the spice of life.&lt;/li&gt;
  &lt;li&gt;Chained assertions. See later&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Rather than some campaign to replace the inbuilt expectations and assertions this library intended to complement them.&lt;/p&gt;&lt;h2&gt;So what is expect.kt?&lt;/h2&gt;&lt;p&gt;Expect.kt is a set of (growing) assertions/expectations that you can use in your kotlin based tests. It gives you a number of ways to assert your expectations and gives you quite descriptive methods in which to do it.&lt;/p&gt;&lt;h3&gt;Expect Syntax&lt;/h3&gt;&lt;p&gt;The expect syntax is the default way to assert things,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="n"&gt;tests&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.junit.Test&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;kotlin.expectations.*&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringExpectationTests&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="nf"&gt;testHelloWorld&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
		&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;toStartWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hell"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
	&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Most of that is boilerplate JUnit testy things but the key line is&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;toStartWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hell"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reads quite nicely IMHO.&lt;/p&gt;&lt;h3&gt;Should Syntax&lt;/h3&gt;&lt;p&gt;The should syntax offers a more fluent syntax if you want to call it that, if we wanted to write the same test above using the should syntax we could do this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;should&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hell"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So rather than wrap your target with an expect you get and extension function to fluently assert it.&lt;/p&gt;&lt;h3&gt;Chaining&lt;/h3&gt;&lt;p&gt;Sometimes making a single assertion on a result isn't enough and rather than write &lt;code&gt;assertTrue(...)&lt;/code&gt; multiple times you can use extpect.kt's chaining support.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="n"&gt;expect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;toStartWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hell"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;and&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toEndWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"rld"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or, with the should syntax,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="s"&gt;"Hello World"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;should&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hell"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;and&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;endWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"rld"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's a bit more readable than expect after expect, right?&lt;/p&gt;&lt;p&gt;So thats it for now - there are a number of assertions implemented already on the useful types (Strings, Ints, Doubles, Dates, Booleans for example) and there are more planned on the way. Currently you'll be wanting to build from source (or copy/paste what you need).&lt;/p&gt;&lt;p&gt;Finally - A shout out to .NETs &lt;a href="http://fluentassertions.codeplex.com/"&gt;FluentAssertions&lt;/a&gt; where a lot of the assertions found their origin!&lt;/p&gt;&lt;p&gt;&lt;a href="https://github.com/kouphax/expect.kt"&gt;expect.kt&lt;/a&gt;.&lt;/p&gt;</content></entry><entry><title>expect.kt: Fluent assertions for Kotlin</title><updated>Fri Jul 20 00:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="http://yobriefca.se/expect.kt"></link><id>urn:yobriefca-se:feed:post:expect.kt: Fluent assertions for Kotlin</id><content type="html"></content></entry><entry><title>Kotlin: Nullable Extensions</title><updated>Tue Jul 17 23:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/07/17/kotlin-nullable-extensions/"></link><id>urn:yobriefca-se:feed:post:Kotlin: Nullable Extensions</id><content type="html">&lt;p&gt;Haskell doesn't have if statements - that blew my mind the first time my old Scala mentor told me it. &lt;code&gt;if&lt;/code&gt;s just don't work with a strong function approach. Plus you know what - &lt;code&gt;if&lt;/code&gt;s are rather ugly especially when you need to wrap ALL THE THINGS in a null check. Scala has a type called &lt;code&gt;Option&lt;/code&gt;. An &lt;code&gt;Option&lt;/code&gt; is essentially a collection of none or one instances of a type. If everything returned an &lt;code&gt;Option&lt;/code&gt; nothing would be null and you don't need to do any null checks (they are much more powerful than I am making out but for now this is all that is necessary).&lt;/p&gt;&lt;p&gt;Kotlin doesn't have the &lt;code&gt;Option&lt;/code&gt; type but it does have two things that allow you to act like it does,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Nullable types - e.g. &lt;code&gt;String&lt;/code&gt; vs &lt;code&gt;String?&lt;/code&gt; , and,&lt;/li&gt;
  &lt;li&gt;Nullable Extension Functions&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Remember the brief definition of an &lt;code&gt;Option&lt;/code&gt; - it's a list of 0 or 1 instances of a particualr type and as such we can treat it a bit like a list. Now once we get functional with our badselves this makes null handling unnecessary. We can use all those nice little functional methods that you get with collections - map, forEach, filter, fold etc.&lt;/p&gt;&lt;p&gt;This means you're less inclined to use &lt;code&gt;if&lt;/code&gt;s and, more importantly, less inclined to use mutable variables which is great for building performant, scalable soltions.&lt;/p&gt;&lt;p&gt;Lets take a really contrived example to show you what I mean. OImagine this bit of code....&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;   &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;authenticate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;
   
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
   		&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;views&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;login&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Invalid Username or Password"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
   		&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;views&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;index&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We want to authenticate a user and return a certain view. Now yes we could refactor this down into something more bitsize but this is a very common state to find code - so bare with me for demonstration purposes.&lt;/p&gt;&lt;p&gt;&lt;code&gt;authenticate&lt;/code&gt; returns a user if the username and password was correct otherwise it returns null. With our nullable extensions (by importing &lt;code&gt;kotlin.nullable.*&lt;/code&gt;) we can reduce this into something more Scala-like,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java "&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;authenticate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;views&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;index&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="o"&gt;?:&lt;/span&gt; &lt;span class="n"&gt;views&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;login&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Invalid Username or Password"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So what we have done here is basically take an object (the user), if it exists, and transform it to another object which we return. Otherwise we return something different. This is much simpler and avoids having to create a mutable var (yes we could have avoided that in the other example but in many cases its very difficult to achieve this). In fact I am not even a fan of the elvis operator there (&lt;code&gt;?:&lt;/code&gt;) and have a Scala-like syntax &lt;a href="https://github.com/JetBrains/kotlin/pull/100"&gt;pull request&lt;/a&gt; open for getOrElse. A small syntactic change that I think allows you create a much neater, chainable block of code.&lt;/p&gt;&lt;p&gt;Thats only the tip of the iceberg on Nullable Extensions - those of you with a functional mind will be able to put these collection-like extensions to great use I reckon. Not quite Scalas &lt;code&gt;Option&lt;/code&gt; type but good enough at providing the common features for me.&lt;/p&gt;</content></entry><entry><title>Kotlin: Extension Functions</title><updated>Sun Jul 15 23:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/07/15/kotlin-extension-functions/"></link><id>urn:yobriefca-se:feed:post:Kotlin: Extension Functions</id><content type="html">&lt;p&gt;In any language (that supports the concept) extension functions are nothing more than syntactic sugar. Instead of writing,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;StringUtils.encrypt(mystring, "salt")
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Extension functions allow you to write,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;mystring.encrypt("salt")
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Once you start moving into the world of chaining things get much cleaner.&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;encrypted = StringUtils.encrypt(mystring, "salt")
encoded = StringUtils.encode(encrypted, "UTF-8")
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or worse,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;StringUtils.encode(StringUtils.encrypt(mystring, "salt"), "UTF-8")
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I've seen this done a few times, it happens. But with sugary sweet extension functions (Extension Methods in C#, Implicit Conversions in Scala) you could just do this,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;mystring.encrypt("salt").encode("UTF-8")
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Much nicer.&lt;/p&gt;&lt;p&gt;Kotlin, unlike crusty old Java, supports extension functions. Here is how you'd implement the methods above&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java"&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;encrypt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;salt:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;StringBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;salt&lt;/span&gt;&lt;span class="o"&gt;)?.&lt;/span&gt;&lt;span class="na"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;encode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;encoding:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ByteArray&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we can use these, as you'd expect, like so,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java"&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;args:&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;mystring&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"james"&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;encoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mystring&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;encrypt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"salt"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;encode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"UTF-8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So what identified those functions as Extension Functions? Simple - the prefixing of the method name with the type &lt;code&gt;String.encode&lt;/code&gt;. No need to create implicit wrappers (Scala), no need to create loads of static classes (C#). And yes it's possible to use generics in these methods as well,&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java"&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;?.&lt;/span&gt;&lt;span class="na"&gt;getOrElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;t:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="o"&gt;?:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can be applied to any nullable type.&lt;/p&gt;&lt;h2&gt;Literal Extension Functions&lt;/h2&gt;&lt;p&gt;An interesting little feature that Kotlin has that makes it a bit different is the use of function literal extension functions. Basically where you can declare a function as a literal (a lambda method if you will) you can also make that literal an extension function,&lt;/p&gt;&lt;p&gt;So we could take our methods we wrote above and bring them right into our &lt;code&gt;main&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight"&gt;&lt;code class="java"&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;args:&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;encrypt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.(&lt;/span&gt;&lt;span class="nl"&gt;salt:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;StringBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;salt&lt;/span&gt;&lt;span class="o"&gt;)?.&lt;/span&gt;&lt;span class="na"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="o"&gt;()}&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;encode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.(&lt;/span&gt;&lt;span class="nl"&gt;encoding:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBytes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
    
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;mystring&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"james"&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="n"&gt;encoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mystring&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;encrypt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"salt"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;encode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"UTF-8"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This may seem quite unnecessary at first glance but it become quite powerful when creating DSLs - as demonstrated in the docs around the &lt;a href="http://confluence.jetbrains.net/display/Kotlin/Type-safe+Groovy-style+builders"&gt;Groovy Style Builders&lt;/a&gt;&lt;/p&gt;&lt;p&gt;So Kotlin has extension functions that don't require a load of boilerplate (C#) or rather odd implicit syntax (Scala) - cool, right?&lt;/p&gt;</content></entry><entry><title>Kotlin: Here's What I Think (For Now)</title><updated>Sat Jul 14 23:00:00 UTC 2012</updated><author><name>James Hughes</name></author><link href="https://yobriefca.se/blog/2012/07/14/kotlin-heres-what-i-think-for-now/"></link><id>urn:yobriefca-se:feed:post:Kotlin: Here's What I Think (For Now)</id><content type="html">&lt;blockquote&gt;&lt;p&gt;Before I go shooting my mouth off here - a word of warning - I haven't really done anything with Kotlin. I've read the docs, played with the &lt;a href="https://github.com/dodyg/Kotlin101"&gt;Kotlin 101 samples&lt;/a&gt; and written a few small console type apps. So take what you want from this post.&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Want to hear something zany? There actually are people - real living people, with a fully working brain, many much smarter than me - that are "happy" with Java. &lt;/p&gt;&lt;p&gt;Seriously.&lt;/p&gt;&lt;p&gt;I made a move from Java to .NET about 5 years ago and have dipped back in a few times over that period. Trying new languages is a sure fire way, for some at least, to make you realise Java is not a language that makes coding fun, or productive. Java put me right of the JVM. Any language that makes woking with collections (something you'll do alot) so long winded and noisy deserves to be shunned. But this isn't a Java rant - the JVM is great but it's just marketed badly because of Java.&lt;/p&gt;&lt;p&gt;But all the JVM-hate that Java instilled in me 5 years ago; the last 6 months of working with Scala has replaced with love. So I've been looking around the JVM world and discovered &lt;a href="http://kotlin.jetbrains.org/"&gt;Kotlin&lt;/a&gt; a new JVM based language from JetBrains. Its much closer to Java than what Scala or Clojure is (intentionally).&lt;/p&gt;&lt;p&gt;One main thing that Kotlin brings to the table is pragmatism. Without trying to belittle Kotlin - it's almost like CoffeeScript for Java (yep kind of like what &lt;a href="http://www.eclipse.org/xtend/"&gt;Xtend&lt;/a&gt; is. Kotlin removes all those annoying necessities in Java that make your code verbose (checked exceptions, semi-colons, null reference checks etc.). It also adds things that make your life much easier (extension methods, functional collection manipulation etc.). &lt;/p&gt;&lt;p&gt;When you write Ruby for the first time you notice that many things just work out like you'd expect, the syntax is quite natural. The same cannot be said for Java - there is just way too much boilerplate. Kotlin helps reduce that boilerplate. So, by extension, it could be said that Kotlin makes you more productive. A person who knows Java will find Kotlin no challenge to start using - the syntax is nicely aligned, just without the noise.&lt;/p&gt;&lt;p&gt;Many people, when trying to get their team to adopt Scala, use the "you can use Scala like Java til you get used to it" mantra. I don't agree with that. Academically it's true but the minute you start working with other peoples Scala code - you've just gotta know Scala and when they have a slew of Implicits thrown in your Scala as Java stuff goes out the window. Kotlin, on the other hand, has some of the nice functional patterns from Scala but none of the "magic-to-a-newcomer" features that can make grown men weep. Now the Kotlin docs themselves even go as far as stating &lt;/p&gt;
&lt;blockquote&gt;
  &lt;pre class="highlight"&gt;&lt;code&gt;If you are happy with Scala, you probably don't need Kotlin.
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;p&gt;But I think they are selling themselves short - I think plenty of people use Scala but could easily use Kotlin in its place and find themselves in a better place (easier upskilling, less cryptic codebase).&lt;/p&gt;&lt;p&gt;Anyway this is a bit of a ramble, what I'm saying is - Kotlin has some really rather nice features (Groovy Like DSL Builders, Pattern Matching, the &lt;code&gt;when&lt;/code&gt; expression, lambdas, Kotlin to JavaScript compilation(!) etc.) and people happy with either Java OR Scala should give it a go.&lt;/p&gt;</content></entry></feed>